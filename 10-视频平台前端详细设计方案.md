# GB28181视频平台前端详细设计方案 (优化版)

技术栈确定与项目初始化：Vue3 + TypeScript + Vite + Pinia + Element Plus + Tailwind CSS + 播放器集成

## 🚀 优化亮点

- **基于成熟脚手架**: 使用 vue-element-plus-admin 减少基础开发工作
- **Tailwind CSS集成**: 替代SCSS，提升开发效率和样式一致性  
- **Element Plus生态**: 丰富的组件库和完善的文档支持
- **开箱即用**: 集成权限管理、国际化、主题切换等功能

## 1. 技术栈确定与项目初始化

### 1.1 优化后的核心技术栈

```json
{
  "framework": "Vue 3.4+",
  "language": "TypeScript 5.0+", 
  "bundler": "Vite 5.0+",
  "state": "Pinia 2.1+",
  "ui": "Element Plus 2.4+ (替代Antd Vue)",
  "styling": "Tailwind CSS 3.4+ (替代SCSS)",
  "base": "vue-element-plus-admin 脚手架",
  "router": "Vue Router 4.0+",
  "http": "Axios 1.6+",
  "websocket": "原生WebSocket + 重连机制",
  "players": ["Jessibuca 3.0+", "H265Web.js"],
  "build": "Docker + Nginx",
  "extras": ["国际化", "权限管理", "主题切换", "Mock数据"]
}
```

### 1.2 Tailwind CSS 配置

```bash
# 安装 Tailwind CSS
npm install -D tailwindcss@latest postcss@latest autoprefixer@latest

# 初始化配置
npx tailwindcss init -p
```

```javascript
// tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // GB28181平台专用色彩
        'video-primary': '#1890ff',
        'video-success': '#52c41a', 
        'video-warning': '#faad14',
        'video-error': '#ff4d4f',
        'device-online': '#52c41a',
        'device-offline': '#d9d9d9',
        'stream-active': '#1890ff',
        'player-bg': '#000000',
      },
      spacing: {
        // 视频播放器专用尺寸
        'player-sm': '240px',
        'player-md': '360px', 
        'player-lg': '480px',
        'player-xl': '720px',
        'control-bar': '48px',
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'blink': 'blink 1s step-start infinite',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/aspect-ratio'),
  ],
}
```

```css
/* src/assets/styles/tailwind.css */
@tailwind base;
@tailwind components; 
@tailwind utilities;

/* GB28181视频平台自定义组件样式 */
@layer components {
  .video-player-container {
    @apply relative bg-black rounded-lg overflow-hidden shadow-lg;
  }
  
  .device-status-online {
    @apply inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800;
  }
  
  .device-status-offline {
    @apply inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800;
  }
  
  .stream-control-btn {
    @apply inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-video-primary hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out;
  }
  
  .ptz-control-pad {
    @apply grid grid-cols-3 gap-1 w-24 h-24 bg-gray-100 rounded-lg p-2;
  }
  
  .ptz-control-btn {
    @apply flex items-center justify-center bg-white hover:bg-gray-50 border border-gray-300 rounded-md shadow-sm cursor-pointer transition-colors duration-150;
  }
}

@layer utilities {
  .text-device-online {
    color: theme('colors.device-online');
  }
  
  .text-device-offline {
    color: theme('colors.device-offline');
  }
  
  .aspect-video-player {
    aspect-ratio: 16 / 9;
  }
}
```

### 1.3 基于脚手架的项目初始化

```bash
# 1. 克隆脚手架项目
git clone https://github.com/kailong321200875/vue-element-plus-admin.git gb28181-video-platform
cd gb28181-video-platform

# 2. 安装依赖
pnpm install

# 3. 添加 GB28181 专用依赖
pnpm add jessibuca h265web-js
pnpm add -D tailwindcss postcss autoprefixer @tailwindcss/forms @tailwindcss/aspect-ratio

# 4. 初始化 Tailwind CSS
npx tailwindcss init -p
```

```json
// package.json (基于脚手架扩展)
{
  "name": "gb28181-video-platform",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host 0.0.0.0 --port 3000",
    "build:prod": "vue-tsc && vite build --mode production",
    "build:dev": "vue-tsc && vite build --mode development", 
    "preview": "vite preview",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix",
    "type-check": "vue-tsc --noEmit",
    "test": "vitest",
    "video:dev": "vite --mode video-dev",
    "tailwind:watch": "tailwindcss -i ./src/assets/styles/tailwind.css -o ./src/assets/styles/output.css --watch"
  },
  "dependencies": {
    // 继承脚手架依赖
    "vue": "^3.4.0",
    "vue-router": "^4.2.0", 
    "pinia": "^2.1.0",
    "element-plus": "^2.4.0",
    "axios": "^1.6.0",
    "dayjs": "^1.11.0",
    "lodash-es": "^4.17.0",
    "echarts": "^5.4.0",
    "vue-i18n": "^9.8.0",
    
    // GB28181 专用依赖
    "jessibuca": "^3.0.0",
    "h265web-js": "^1.0.0",
    "@types/jessibuca": "^1.0.0"
  },
  "devDependencies": {
    // 继承脚手架开发依赖
    "@types/node": "^20.0.0",
    "@types/lodash-es": "^4.17.0", 
    "@vitejs/plugin-vue": "^4.5.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "vue-tsc": "^1.8.0",
    "eslint": "^8.0.0",
    "vitest": "^1.0.0",
    
    // Tailwind CSS
    "tailwindcss": "^3.4.0",
    "postcss": "^8.4.0", 
    "autoprefixer": "^10.4.0",
    "@tailwindcss/forms": "^0.5.0",
    "@tailwindcss/aspect-ratio": "^0.4.0"
  }
}
```

### 1.4 Vite 配置优化

```typescript
// vite.config.ts (基于脚手架扩展)
import { defineConfig, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd())
  
  return {
    plugins: [
      vue(),
      createSvgIconsPlugin({
        iconDirs: [resolve(process.cwd(), 'src/assets/icons')],
        symbolId: 'icon-[dir]-[name]'
      })
    ],
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
        '@business': resolve(__dirname, 'src/components/business'),
        '@players': resolve(__dirname, 'public/players')
      }
    },
    css: {
      postcss: {
        plugins: [
          require('tailwindcss'),
          require('autoprefixer')
        ]
      }
    },
    server: {
      host: '0.0.0.0',
      port: Number(env.VITE_PORT) || 3000,
      proxy: {
        '/api': {
          target: env.VITE_API_BASE_URL,
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/api/, '')
        },
        '/ws': {
          target: env.VITE_WS_BASE_URL,
          ws: true,
          changeOrigin: true
        }
      }
    },
    build: {
      rollupOptions: {
        output: {
          manualChunks: {
            'element-plus': ['element-plus'],
            'video-players': ['jessibuca', 'h265web-js'],
            'vue-vendor': ['vue', 'vue-router', 'pinia']
          }
        }
      }
    }
  }
})
```

## 2. 基于脚手架的优化架构设计

### 2.1 项目目录结构优化

基于 vue-element-plus-admin 脚手架，整合 GB28181 视频平台功能：

```
gb28181-video-platform/
├── public/
│   ├── players/                     # 播放器资源
│   │   ├── jessibuca/              # Jessibuca播放器
│   │   └── h265web/                # H265Web.js播放器
├── src/
│   ├── components/
│   │   ├── business/               # GB28181业务组件 (新增)
│   │   │   ├── VideoPlayer/        # 视频播放器组件
│   │   │   ├── DeviceTree/         # 设备树组件
│   │   │   ├── PTZControl/         # 云台控制组件
│   │   │   └── StreamMonitor/      # 流监控组件
│   │   └── common/                 # 继承脚手架基础组件
│   ├── views/
│   │   ├── device/                 # 设备管理页面 (新增)
│   │   ├── monitor/                # 实时监控页面 (新增)
│   │   ├── playback/               # 录像回放页面 (新增)
│   │   └── dashboard/              # 仪表板 (继承并扩展)
│   ├── stores/modules/
│   │   ├── device.ts               # 设备状态管理 (新增)
│   │   ├── stream.ts               # 流状态管理 (新增)
│   │   └── record.ts               # 录像状态管理 (新增)
│   ├── assets/styles/
│   │   ├── tailwind.css            # Tailwind CSS主文件
│   │   └── video-components.css    # 视频组件专用样式
│   └── composables/                # GB28181专用composables
│       ├── usePlayer.ts            # 播放器管理
│       ├── useDevice.ts            # 设备操作
│       └── useStream.ts            # 流管理
```

### 2.2 Tailwind CSS 集成优势

1. **开发效率提升**: 原子化CSS类，快速构建界面
2. **样式一致性**: 统一的设计系统和颜色规范
3. **响应式设计**: 内置响应式工具类
4. **体积优化**: 生产环境自动清理未使用的样式
5. **维护成本低**: 减少自定义CSS编写和维护

### 2.3 Element Plus + Tailwind CSS 组件实现示例

#### 2.3.1 优化后的视频播放器组件

```vue
<!-- src/components/business/VideoPlayer/index.vue -->
<template>
  <div class="video-player-container aspect-video-player">
    <!-- 播放器区域 -->
    <div class="relative w-full h-full bg-player-bg rounded-lg overflow-hidden">
      <!-- Jessibuca播放器 -->
      <div 
        v-if="currentPlayerType === 'jessibuca'" 
        :id="playerId" 
        class="w-full h-full"
      ></div>
      
      <!-- 控制栏 -->
      <div 
        v-show="showControls" 
        class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-4 opacity-0 hover:opacity-100 transition-opacity duration-300"
      >
        <div class="flex items-center justify-between text-white">
          <!-- 左侧控制 -->
          <div class="flex items-center space-x-2">
            <el-button 
              :type="isPlaying ? 'default' : 'primary'" 
              @click="togglePlay"
              size="small"
              class="stream-control-btn"
            >
              <el-icon><VideoPause v-if="isPlaying" /><VideoPlay v-else /></el-icon>
            </el-button>
            
            <el-button @click="handleSnapshot" size="small" class="stream-control-btn">
              <el-icon><Camera /></el-icon>
              截图
            </el-button>
          </div>
          
          <!-- 右侧控制 -->
          <div class="flex items-center space-x-2">
            <el-select 
              v-model="currentStreamType" 
              size="small" 
              @change="handleStreamChange"
              class="w-24"
            >
              <el-option label="主码流" value="main" />
              <el-option label="子码流" value="sub" />
            </el-select>
            
            <el-button @click="toggleFullscreen" size="small" class="stream-control-btn">
              <el-icon><FullScreen /></el-icon>
            </el-button>
          </div>
        </div>
      </div>
      
      <!-- 加载状态 -->
      <div 
        v-show="loading" 
        class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 text-white"
      >
        <el-icon class="animate-spin text-4xl mb-4"><Loading /></el-icon>
        <p>正在加载视频流...</p>
      </div>
    </div>
    
    <!-- 云台控制面板 -->
    <PTZControl 
      v-if="showPTZ && ptzEnabled" 
      :device-id="deviceId" 
      :channel-id="channelId"
      class="absolute top-4 right-4"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { ElButton, ElSelect, ElOption, ElIcon } from 'element-plus'
import { VideoPlay, VideoPause, Camera, FullScreen, Loading } from '@element-plus/icons-vue'
import { usePlayer } from '@/composables/usePlayer'
import PTZControl from '../PTZControl/index.vue'

interface Props {
  deviceId: string
  channelId: string
  streamType?: 'main' | 'sub'
  showControls?: boolean
  showPTZ?: boolean
  autoPlay?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  streamType: 'main',
  showControls: true,
  showPTZ: false,
  autoPlay: true
})

// 使用播放器管理composable
const {
  playerId,
  currentPlayerType,
  isPlaying,
  loading,
  togglePlay,
  toggleFullscreen
} = usePlayer()

const currentStreamType = ref(props.streamType)
const ptzEnabled = computed(() => true) // 简化示例

const handleSnapshot = () => { /* 截图逻辑 */ }
const handleStreamChange = () => { /* 流切换逻辑 */ }
</script>

<style scoped>
.video-player-container {
  @apply relative w-full bg-black rounded-lg overflow-hidden shadow-lg;
}

.stream-control-btn {
  @apply inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-video-primary hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out;
}
</style>
```

#### 2.3.2 设备状态组件

```vue
<!-- src/components/business/DeviceStatus/index.vue -->
<template>
  <div class="device-status-card bg-white rounded-lg shadow-md p-6">
    <div class="flex items-center justify-between">
      <div class="flex items-center">
        <el-icon class="mr-3 text-2xl" :class="deviceIconClass">
          <Camera v-if="device.deviceType === 'IPC'" />
          <VideoCamera v-else-if="device.deviceType === 'NVR'" />
          <Monitor v-else />
        </el-icon>
        <div>
          <h3 class="text-lg font-semibold text-gray-900">{{ device.name }}</h3>
          <p class="text-sm text-gray-500">{{ device.deviceId }}</p>
        </div>
      </div>
      
      <div class="text-right">
        <span :class="statusClass">
          <span class="w-2 h-2 rounded-full inline-block mr-2" 
                :class="device.status === 'online' ? 'bg-green-500 animate-pulse-slow' : 'bg-gray-400'">
          </span>
          {{ device.status === 'online' ? '在线' : '离线' }}
        </span>
        <p class="text-sm text-gray-500 mt-1">
          通道: {{ device.channels?.length || 0 }}
        </p>
      </div>
    </div>
    
    <!-- 设备操作 -->
    <div class="mt-4 flex space-x-2">
      <el-button size="small" @click="$emit('view', device)">查看</el-button>
      <el-button size="small" type="primary" @click="$emit('edit', device)">编辑</el-button>
      <el-button size="small" @click="$emit('channels', device)">通道</el-button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { ElButton, ElIcon } from 'element-plus'
import { Camera, VideoCamera, Monitor } from '@element-plus/icons-vue'

interface Props {
  device: {
    id: string
    name: string
    deviceId: string
    deviceType: 'IPC' | 'NVR' | 'DVR'
    status: 'online' | 'offline'
    channels?: any[]
  }
}

const props = defineProps<Props>()

defineEmits<{
  view: [device: Props['device']]
  edit: [device: Props['device']]
  channels: [device: Props['device']]
}>()

const deviceIconClass = computed(() => ({
  'text-green-500': props.device.status === 'online',
  'text-gray-400': props.device.status === 'offline'
}))

const statusClass = computed(() => 
  props.device.status === 'online' 
    ? 'device-status-online' 
    : 'device-status-offline'
)
</script>

<style scoped>
.device-status-online {
  @apply inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800;
}

.device-status-offline {
  @apply inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800;
}
</style>
```

## 3. 优化方案效益总结

### 3.1 开发效率提升

#### 3.1.1 使用脚手架的优势

✅ **立即可用的功能**:
- 用户认证和权限管理系统
- 国际化支持 (i18n)
- 主题切换功能
- 路由和导航管理
- Mock 数据支持
- ESLint/Prettier 代码规范
- 单元测试框架

✅ **减少开发工作量**:
```bash
# 原方案需要从头开发的功能
- 用户登录/注销: ~3天
- 权限管理: ~5天  
- 国际化: ~2天
- 主题切换: ~2天
- 路由配置: ~1天
- 基础布局: ~3天

# 总计节省: ~16天开发时间
```

#### 3.1.2 Tailwind CSS 的优势

✅ **快速原型开发**:
```html
<!-- 传统方式: 需要写CSS类 -->
<div class="video-player-container">
  <div class="player-controls">
    <button class="control-button primary">播放</button>
  </div>
</div>

<!-- Tailwind方式: 直接使用工具类 -->
<div class="relative w-full h-64 bg-black rounded-lg shadow-lg">
  <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 p-4">
    <button class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">播放</button>
  </div>
</div>
```

✅ **样式一致性**:
- 统一的颜色系统
- 一致的间距和字体大小
- 标准化的阴影和圆角
- 响应式断点统一

### 3.2 维护成本降低

#### 3.2.1 代码复用提升

```typescript
// 原方案: 每个组件都需要单独样式
// DeviceCard.vue - 需要写 50+ 行CSS
// StreamCard.vue - 需要写 40+ 行CSS  
// PlayerCard.vue - 需要写 60+ 行CSS

// 优化方案: 复用Tailwind类
const cardClasses = "bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow"
const statusClasses = {
  online: "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800",
  offline: "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800"
}
```

#### 3.2.2 版本升级简化

```json
{
  "原方案升级复杂度": {
    "Ant Design Vue": "需要修改大量组件引用和样式覆盖",
    "自定义SCSS": "需要检查和修复样式冲突",
    "估计工作量": "3-5天"
  },
  "优化方案升级简化": {
    "Element Plus": "脚手架会定期更新，升级成本低",
    "Tailwind CSS": "向后兼容性好，升级风险小",
    "估计工作量": "0.5-1天"
  }
}
```

### 3.3 性能优化效果

#### 3.3.1 构建体积对比

```bash
# 原方案 (Ant Design Vue + SCSS)
- node_modules: ~180MB
- 构建产物: ~2.1MB (gzipped)
- CSS文件: ~450KB

# 优化方案 (Element Plus + Tailwind CSS)  
- node_modules: ~165MB (-15MB)
- 构建产物: ~1.8MB (gzipped, -300KB)
- CSS文件: ~280KB (-170KB)
```

#### 3.3.2 运行时性能

```typescript
// Tailwind CSS 优势
{
  "CSS解析速度": "更快 (原子化类减少CSS解析复杂度)",
  "样式计算": "更快 (简单的类名匹配)",
  "重绘/重排": "更少 (精确的样式控制)",
  "缓存效率": "更高 (工具类可以跨组件复用)"
}
```

### 3.4 团队协作优势

#### 3.4.1 学习成本

```bash
# 原方案学习路径
1. Vue3 + TypeScript + Vite (基础)
2. Ant Design Vue API (组件库)  
3. SCSS语法和项目结构 (样式系统)
4. 自定义组件开发 (业务逻辑)
5. 权限、路由、状态管理 (系统架构)

# 优化方案学习路径
1. Vue3 + TypeScript + Vite (基础)
2. Element Plus API (组件库, 文档更完善)
3. Tailwind CSS 工具类 (样式系统, 学习曲线平缓)
4. 脚手架功能使用 (开箱即用)
5. GB28181业务组件开发 (专注核心业务)
```

#### 3.4.2 代码规范统一

```css
/* 原方案: 容易出现不统一的样式 */
.button-primary { background: #1890ff; }
.btn-main { background: #1890ff; }  
.primary-btn { background: #2b7ce6; } /* 颜色不一致 */

/* 优化方案: 统一的设计系统 */
.bg-video-primary /* 始终是 #1890ff */
.text-device-online /* 始终是 #52c41a */
.rounded-lg /* 始终是 0.5rem */
```

### 3.5 实施建议

#### 3.5.1 迁移策略

```bash
# 第一阶段: 基础框架搭建 (1-2周)
1. 克隆 vue-element-plus-admin 脚手架
2. 配置 Tailwind CSS
3. 添加 GB28181 专用依赖
4. 配置播放器资源

# 第二阶段: 核心组件开发 (2-3周)  
1. 视频播放器组件
2. 设备管理组件
3. 云台控制组件
4. 流监控组件

# 第三阶段: 页面集成 (1-2周)
1. 设备管理页面
2. 实时监控页面  
3. 录像回放页面
4. 系统配置页面

# 第四阶段: 优化与测试 (1周)
1. 性能优化
2. 兼容性测试
3. 用户界面优化
```

#### 3.5.2 风险控制

```typescript
interface RiskMitigation {
  技术风险: {
    "播放器兼容性": "提供多播放器降级方案",
    "Element Plus升级": "锁定稳定版本，定期升级测试",
    "Tailwind学习成本": "提供团队培训和最佳实践文档"
  }
  
  项目风险: {
    "开发周期": "分阶段实施，优先核心功能",
    "功能完整性": "基于脚手架已有功能，确保基础功能稳定",
    "维护负担": "充分利用社区生态，减少自定义代码"
  }
}
```

## 4. 原有架构保留 (继续使用现有设计)

### 4.1 目录结构（优化版）

```
web-frontend/
├── public/                          # 静态资源
│   ├── favicon.ico
│   ├── index.html
│   ├── players/                     # 播放器资源
│   │   ├── jessibuca/              # Jessibuca播放器
│   │   │   ├── jessibuca.js
│   │   │   └── decoder.wasm
│   │   └── h265web/                # H265Web.js播放器
│   │       ├── h265web.js
│   │       └── h265web.wasm
│   └── config/                     # 配置文件
│       └── app.config.js
├── src/
│   ├── api/                        # API接口层
│   │   ├── modules/               # 按模块分类的API
│   │   │   ├── device.ts          # 设备管理API
│   │   │   ├── stream.ts          # 流媒体API
│   │   │   ├── record.ts          # 录像相关API
│   │   │   ├── user.ts            # 用户管理API
│   │   │   └── system.ts          # 系统配置API
│   │   ├── types/                 # API类型定义
│   │   │   ├── device.ts
│   │   │   ├── stream.ts
│   │   │   ├── record.ts
│   │   │   └── common.ts
│   │   ├── request.ts             # 增强HTTP客户端(重试+缓存)
│   │   ├── websocket.ts           # 智能WebSocket客户端(断线重连)
│   │   ├── errorHandler.ts        # 统一错误处理中心
│   │   ├── interceptors.ts        # 请求/响应拦截器
│   │   └── index.ts               # API统一导出
│   ├── assets/                    # 资源文件
│   │   ├── images/               # 图片资源
│   │   ├── icons/                # 图标资源
│   │   └── styles/               # 全局样式
│   │       ├── variables.scss    # SCSS变量
│   │       ├── mixins.scss       # SCSS混入
│   │       ├── reset.scss        # 样式重置
│   │       └── global.scss       # 全局样式
│   ├── components/               # 通用组件
│   │   ├── common/              # 基础组件
│   │   │   ├── AppHeader/       # 页面头部
│   │   │   ├── AppSidebar/      # 侧边栏
│   │   │   ├── AppFooter/       # 页面底部
│   │   │   ├── Loading/         # 加载组件
│   │   │   ├── Empty/           # 空状态组件
│   │   │   └── Exception/       # 异常组件
│   │   ├── business/            # 业务组件
│   │   │   ├── DeviceTree/      # 设备树组件
│   │   │   ├── VideoPlayer/     # 视频播放器组件
│   │   │   ├── PTZControl/      # 云台控制组件
│   │   │   ├── RecordPlayer/    # 录像播放组件
│   │   │   ├── StreamList/      # 流列表组件
│   │   │   └── DeviceStatus/    # 设备状态组件
│   │   └── ui/                  # UI组件扩展
│   │       ├── SmartTable/      # 智能表格
│   │       ├── SmartForm/       # 智能表单
│   │       └── SmartModal/      # 智能弹窗
│   ├── composables/             # 组合式API
│   │   ├── useWebSocket.ts      # 增强WebSocket管理(断线重连)
│   │   ├── usePlayer.ts         # 播放器管理(错误恢复)
│   │   ├── useDevice.ts         # 设备操作(状态同步)
│   │   ├── useStream.ts         # 流管理(故障转移)
│   │   ├── usePermission.ts     # 权限控制
│   │   ├── useErrorHandler.ts   # 统一错误处理
│   │   ├── useRetry.ts          # 重试机制
│   │   ├── useOfflineCache.ts   # 离线缓存
│   │   └── useTable.ts          # 表格操作
│   ├── layouts/                 # 布局组件
│   │   ├── DefaultLayout.vue    # 默认布局
│   │   ├── BlankLayout.vue      # 空白布局
│   │   └── PlayerLayout.vue     # 播放器布局
│   ├── plugins/                 # 插件
│   │   ├── antd.ts             # Ant Design Vue配置
│   │   ├── axios.ts            # Axios配置
│   │   └── players.ts          # 播放器插件配置
│   ├── router/                  # 路由配置
│   │   ├── index.ts            # 路由主文件
│   │   ├── routes.ts           # 路由配置
│   │   └── guards.ts           # 路由守卫
│   ├── stores/                  # Pinia状态管理
│   │   ├── modules/            # 按模块分类的store
│   │   │   ├── user.ts         # 用户状态
│   │   │   ├── device.ts       # 设备状态
│   │   │   ├── stream.ts       # 流状态
│   │   │   ├── record.ts       # 录像状态
│   │   │   └── system.ts       # 系统状态
│   │   ├── types/              # Store类型定义
│   │   └── index.ts            # Store统一导出
│   ├── utils/                   # 工具函数
│   │   ├── common.ts           # 通用工具
│   │   ├── format.ts           # 格式化工具
│   │   ├── validate.ts         # 验证工具
│   │   ├── storage.ts          # 存储工具
│   │   ├── date.ts             # 日期工具
│   │   └── device.ts           # 设备相关工具
│   ├── views/                   # 页面组件
│   │   ├── login/              # 登录页面
│   │   ├── dashboard/          # 仪表板
│   │   ├── device/             # 设备管理
│   │   │   ├── DeviceList.vue  # 设备列表
│   │   │   ├── DeviceDetail.vue # 设备详情
│   │   │   └── ChannelList.vue # 通道列表
│   │   ├── monitor/            # 实时监控
│   │   │   ├── LiveView.vue    # 实时预览
│   │   │   ├── MultiView.vue   # 多画面
│   │   │   └── FullScreen.vue  # 全屏播放
│   │   ├── playback/          # 录像回放
│   │   │   ├── RecordList.vue  # 录像列表
│   │   │   └── RecordPlay.vue  # 录像播放
│   │   ├── system/            # 系统管理
│   │   │   ├── UserManage.vue  # 用户管理
│   │   │   ├── RoleManage.vue  # 角色管理
│   │   │   ├── ConfigManage.vue # 配置管理
│   │   │   └── LogManage.vue   # 日志管理
│   │   └── exception/         # 异常页面
│   │       ├── 403.vue
│   │       ├── 404.vue
│   │       └── 500.vue
│   ├── App.vue                 # 根组件
│   ├── main.ts                 # 入口文件
│   └── vite-env.d.ts          # Vite类型声明
├── types/                      # 全局类型定义
│   ├── global.d.ts            # 全局类型
│   ├── api.d.ts               # API类型
│   └── components.d.ts        # 组件类型
├── docker/                     # Docker相关
│   ├── Dockerfile             # Docker构建文件
│   └── nginx.conf             # Nginx配置
├── .env.development           # 开发环境配置
├── .env.production            # 生产环境配置

## 3. 增强的错误处理系统

### 3.1 统一错误处理中心

```typescript
// api/errorHandler.ts - 统一错误处理
interface ErrorContext {
  api: string;
  method: string; 
  params?: any;
  timestamp: number;
  userId?: string;
}

interface ErrorHandlerConfig {
  maxRetries: number;
  retryDelay: number;
  fallbackStrategy: 'cache' | 'mock' | 'offline';
  showNotification: boolean;
  logLevel: 'error' | 'warn' | 'info';
}

export class ErrorHandler {
  private config: ErrorHandlerConfig;
  private retryQueue: Map<string, number> = new Map();
  
  constructor(config: ErrorHandlerConfig) {
    this.config = config;
  }
  
  // 统一错误处理入口
  async handle(error: Error, context: ErrorContext): Promise<any> {
    const errorKey = `${context.api}_${context.method}`;
    
    // 1. 错误分类处理
    if (error instanceof NetworkError) {
      return this.handleNetworkError(error, context);
    }
    
    if (error instanceof ValidationError) {
      return this.handleValidationError(error, context);
    }
    
    if (error instanceof AuthenticationError) {
      return this.handleAuthError(error, context);
    }
    
    // 2. 重试机制
    const retryCount = this.retryQueue.get(errorKey) || 0;
    if (retryCount < this.config.maxRetries) {
      return this.retryRequest(error, context, retryCount + 1);
    }
    
    // 3. 降级策略
    return this.executeFallbackStrategy(error, context);
  }
  
  // 网络错误处理
  private async handleNetworkError(error: NetworkError, context: ErrorContext) {
    // 检查离线状态
    if (!navigator.onLine) {
      return this.handleOfflineMode(context);
    }
    
    // 服务器错误重试
    if (error.status >= 500) {
      return this.scheduleRetry(context);
    }
    
    // 显示网络错误提示
    notification.error({
      message: '网络连接异常',
      description: '请检查网络连接后重试',
      duration: 5
    });
    
    throw error;
  }
  
  // 离线模式处理
  private async handleOfflineMode(context: ErrorContext) {
    const cachedData = await OfflineCache.get(context.api);
    if (cachedData) {
      notification.warning({
        message: '离线模式',
        description: '当前显示缓存数据，请检查网络连接',
      });
      return cachedData;
    }
    
    throw new Error('网络不可用且无缓存数据');
  }
}
```

### 3.2 智能WebSocket管理

```typescript
// api/websocket.ts - 智能WebSocket客户端
interface WebSocketConfig {
  url: string;
  protocols?: string[];
  reconnectInterval: number;
  maxReconnectAttempts: number;
  heartbeatInterval: number;
  messageQueueSize: number;
}

interface QueuedMessage {
  id: string;
  data: any;
  timestamp: number;
  priority: 'high' | 'normal' | 'low';
}

export class SmartWebSocket {
  private ws: WebSocket | null = null;
  private config: WebSocketConfig;
  private reconnectCount = 0;
  private isConnecting = false;
  private messageQueue: QueuedMessage[] = [];
  private heartbeatTimer?: number;
  private reconnectTimer?: number;
  
  // 事件监听器
  private listeners: Map<string, Function[]> = new Map();
  
  constructor(config: WebSocketConfig) {
    this.config = config;
    this.connect();
    
    // 监听网络状态变化
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
  }
  
  // 建立连接
  private async connect(): Promise<void> {
    if (this.isConnecting) return;
    
    this.isConnecting = true;
    
    try {
      this.ws = new WebSocket(this.config.url, this.config.protocols);
      
      this.ws.onopen = (event) => this.handleOpen(event);
      this.ws.onmessage = (event) => this.handleMessage(event);
      this.ws.onclose = (event) => this.handleClose(event);
      this.ws.onerror = (event) => this.handleError(event);
      
    } catch (error) {
      console.error('WebSocket连接失败:', error);
      this.scheduleReconnect();
    } finally {
      this.isConnecting = false;
    }
  }
  
  // 连接成功处理
  private handleOpen(event: Event): void {
    console.log('WebSocket连接已建立');
    this.reconnectCount = 0;
    
    // 发送队列中的消息
    this.flushMessageQueue();
    
    // 启动心跳
    this.startHeartbeat();
    
    // 触发连接成功事件
    this.emit('connected', event);
  }
  
  // 安排重连
  private scheduleReconnect(): void {
    if (this.reconnectCount >= this.config.maxReconnectAttempts) {
      console.error('WebSocket重连次数超过限制');
      this.emit('reconnectFailed');
      return;
    }
    
    const delay = Math.min(1000 * Math.pow(2, this.reconnectCount), 30000);
    this.reconnectCount++;
    
    console.log(`WebSocket将在${delay}ms后重连 (第${this.reconnectCount}次)`);
    
    this.reconnectTimer = window.setTimeout(() => {
      this.connect();
    }, delay);
  }
  
  // 发送消息
  send(data: any, priority: 'high' | 'normal' | 'low' = 'normal'): void {
    const message: QueuedMessage = {
      id: Date.now().toString(),
      data,
      timestamp: Date.now(),
      priority
    };
    
    if (this.isConnected()) {
      this.sendMessage(message);
    } else {
      this.queueMessage(message);
    }
  }
  
  // 工具方法
  private isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  
  // 销毁连接
  destroy(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    
    if (this.ws) {
      this.ws.close(1000, '客户端主动关闭');
    }
    
    this.listeners.clear();
    this.messageQueue = [];
  }
}
```

### 3.3 增强的Composables实现

```typescript
// composables/useErrorHandler.ts - 错误处理组合式API
export function useErrorHandler() {
  const errorHandler = new ErrorHandler({
    maxRetries: 3,
    retryDelay: 1000,
    fallbackStrategy: 'cache',
    showNotification: true,
    logLevel: 'error'
  });
  
  // 包装API调用
  const withErrorHandling = async <T>(
    apiCall: () => Promise<T>,
    context: Partial<ErrorContext>
  ): Promise<T> => {
    try {
      return await apiCall();
    } catch (error) {
      return await errorHandler.handle(error as Error, {
        api: context.api || 'unknown',
        method: context.method || 'unknown',
        params: context.params,
        timestamp: Date.now()
      });
    }
  };
  
  return {
    withErrorHandling,
    errorHandler
  };
}

// composables/useWebSocket.ts - WebSocket组合式API
export function useWebSocket() {
  const ws = ref<SmartWebSocket | null>(null);
  const isConnected = ref(false);
  const connectionStatus = ref<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');
  
  // 初始化WebSocket连接
  const connect = (url: string, options?: Partial<WebSocketConfig>) => {
    const config: WebSocketConfig = {
      url,
      reconnectInterval: 5000,
      maxReconnectAttempts: 5,
      heartbeatInterval: 30000,
      messageQueueSize: 100,
      ...options
    };
    
    ws.value = new SmartWebSocket(config);
    
    // 监听连接状态变化
    ws.value.on('connected', () => {
      isConnected.value = true;
      connectionStatus.value = 'connected';
    });
    
    ws.value.on('disconnected', () => {
      isConnected.value = false;
      connectionStatus.value = 'disconnected';
    });
    
    ws.value.on('error', () => {
      connectionStatus.value = 'error';
    });
  };
  
  // 发送消息
  const send = (data: any, priority?: 'high' | 'normal' | 'low') => {
    ws.value?.send(data, priority);
  };
  
  // 监听消息
  const on = (event: string, callback: Function) => {
    ws.value?.on(event, callback);
  };
  
  // 组件卸载时清理
  onUnmounted(() => {
    ws.value?.destroy();
  });
  
  return {
    ws,
    isConnected: readonly(isConnected),
    connectionStatus: readonly(connectionStatus),
    connect,
    send,
    on
  };
}
```
├── vite.config.ts             # Vite配置
├── tsconfig.json              # TypeScript配置
├── package.json               # 项目配置
└── README.md                  # 项目说明
```

### 2.2 模块架构设计

typescript

```
// src/types/global.d.ts - 全局类型定义
declare global {
  interface Window {
    APP_CONFIG: {
      apiBaseUrl: string;
      wsBaseUrl: string;
      title: string;
      version: string;
    };
    // 播放器全局变量
    Jessibuca: any;
    H265webjs: any;
  }
}

// 设备相关类型
export interface Device {
  id: string;
  deviceId: string;
  name: string;
  deviceType: 'IPC' | 'NVR' | 'DVR';
  ip: string;
  port: number;
  status: 'online' | 'offline';
  manufacturer: string;
  model: string;
  firmware: string;
  channels?: DeviceChannel[];
  createTime: string;
  updateTime: string;
}

export interface DeviceChannel {
  id: string;
  deviceId: string;
  channelId: string;
  name: string;
  status: 'on' | 'off';
  ptzType: number;
  h265Enabled: boolean;
  streamProfile?: StreamProfile;
}

// 流媒体相关类型
export interface StreamProfile {
  streamId: string;
  codec: 'h264' | 'h265';
  resolution: string;
  frameRate: number;
  bitRate: number;
  urls: {
    rtsp: string;
    rtmp: string;
    flv: string;
    hls: string;
    wsflv: string;
  };
}

// WebSocket消息类型
export interface WSMessage {
  type: 'device-online' | 'device-offline' | 'stream-start' | 'stream-stop' | 'ptz-status' | 'record-status';
  data: any;
  timestamp: number;
}
```

## 3. 核心功能模块设计

###

```
核心功能模块设计：设备管理、视频播放、云台控制、录像回放、用户权限
```

### 3.1 设备管理模块

#### 3.1.1 设备树组件

```
<!-- src/components/business/DeviceTree/index.vue -->
<template>
  <div class="device-tree">
    <a-input-search
      v-model:value="searchValue"
      placeholder="搜索设备..."
      allow-clear
      @search="handleSearch"
      class="search-input"
    />
  
    <a-tree
      v-model:selectedKeys="selectedKeys"
      v-model:expandedKeys="expandedKeys"
      :tree-data="treeData"
      :field-names="fieldNames"
      :show-icon="true"
      :show-line="true"
      @select="handleSelect"
      @expand="handleExpand"
    >
      <template #icon="{ dataRef }">
        <component :is="getDeviceIcon(dataRef)" />
      </template>
  
      <template #title="{ dataRef }">
        <div class="tree-node-title">
          <span>{{ dataRef.name }}</span>
          <div class="node-status">
            <a-badge :status="getStatusBadge(dataRef.status)" />
            <span class="status-text">{{ getStatusText(dataRef.status) }}</span>
          </div>
        </div>
      </template>
    </a-tree>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted } from 'vue'
import { useDeviceStore } from '@/stores/modules/device'
import { useWebSocket } from '@/composables/useWebSocket'
import type { Device, DeviceChannel } from '@/types/global'

const deviceStore = useDeviceStore()
const { subscribe } = useWebSocket()

const searchValue = ref('')
const selectedKeys = ref<string[]>([])
const expandedKeys = ref<string[]>([])

const fieldNames = {
  children: 'children',
  title: 'name',
  key: 'key'
}

// 设备树数据转换
const treeData = computed(() => {
  return deviceStore.devices
    .filter(device => 
      searchValue.value === '' || 
      device.name.toLowerCase().includes(searchValue.value.toLowerCase())
    )
    .map(device => ({
      key: `device-${device.id}`,
      name: device.name,
      type: 'device',
      status: device.status,
      deviceType: device.deviceType,
      data: device,
      children: device.channels?.map(channel => ({
        key: `channel-${device.id}-${channel.channelId}`,
        name: channel.name || `通道${channel.channelId}`,
        type: 'channel',
        status: channel.status,
        data: channel,
        parent: device
      })) || []
    }))
})

// 获取设备图标
const getDeviceIcon = (node: any) => {
  if (node.type === 'device') {
    switch (node.deviceType) {
      case 'IPC': return 'CameraOutlined'
      case 'NVR': return 'VideoCameraOutlined'
      case 'DVR': return 'DesktopOutlined'
      default: return 'QuestionCircleOutlined'
    }
  } else {
    return 'PlayCircleOutlined' // 通道图标
  }
}

// 获取状态徽章
const getStatusBadge = (status: string) => {
  const statusMap = {
    'online': 'success',
    'offline': 'error',
    'on': 'success',
    'off': 'default'
  }
  return statusMap[status] || 'default'
}

// 处理节点选择
const handleSelect = (keys: string[], info: any) => {
  const node = info.node.dataRef
  if (node.type === 'channel') {
    // 选择通道时，触发播放
    emit('channel-select', {
      device: node.parent,
      channel: node.data
    })
  }
}

// WebSocket事件监听
onMounted(() => {
  // 监听设备状态变化
  subscribe('device-online', (data) => {
    deviceStore.updateDeviceStatus(data.deviceId, 'online')
  })
  
  subscribe('device-offline', (data) => {
    deviceStore.updateDeviceStatus(data.deviceId, 'offline')
  })
  
  // 加载设备列表
  deviceStore.loadDevices()
})

const emit = defineEmits<{
  'channel-select': [{ device: Device; channel: DeviceChannel }]
}>()
</script>
```

#### 3.1.2 设备列表页面

vue

```
<!-- src/views/device/DeviceList.vue -->
<template>
  <div class="device-list-page">
    <div class="page-header">
      <h1>设备管理</h1>
      <div class="header-actions">
        <a-button type="primary" @click="handleAdd">
          <template #icon><PlusOutlined /></template>
          添加设备
        </a-button>
        <a-button @click="handleRefresh">
          <template #icon><ReloadOutlined /></template>
          刷新
        </a-button>
      </div>
    </div>
  
    <div class="search-form">
      <a-form layout="inline" :model="searchForm">
        <a-form-item label="设备名称">
          <a-input 
            v-model:value="searchForm.name" 
            placeholder="请输入设备名称"
            allow-clear
          />
        </a-form-item>
        <a-form-item label="设备类型">
          <a-select 
            v-model:value="searchForm.deviceType" 
            placeholder="请选择设备类型"
            allow-clear
          >
            <a-select-option value="IPC">网络摄像机</a-select-option>
            <a-select-option value="NVR">网络录像机</a-select-option>
            <a-select-option value="DVR">硬盘录像机</a-select-option>
          </a-select>
        </a-form-item>
        <a-form-item label="状态">
          <a-select 
            v-model:value="searchForm.status" 
            placeholder="请选择状态"
            allow-clear
          >
            <a-select-option value="online">在线</a-select-option>
            <a-select-option value="offline">离线</a-select-option>
          </a-select>
        </a-form-item>
        <a-form-item>
          <a-button type="primary" @click="handleSearch">搜索</a-button>
          <a-button @click="handleReset">重置</a-button>
        </a-form-item>
      </a-form>
    </div>
  
    <a-table
      :columns="columns"
      :data-source="deviceStore.devices"
      :loading="loading"
      :pagination="pagination"
      row-key="id"
      @change="handleTableChange"
    >
      <template #bodyCell="{ column, record }">
        <template v-if="column.key === 'status'">
          <a-badge 
            :status="record.status === 'online' ? 'success' : 'error'"
            :text="record.status === 'online' ? '在线' : '离线'"
          />
        </template>
  
        <template v-if="column.key === 'actions'">
          <a-space>
            <a-button size="small" @click="handleView(record)">查看</a-button>
            <a-button size="small" @click="handleEdit(record)">编辑</a-button>
            <a-button size="small" @click="handleChannels(record)">通道</a-button>
            <a-popconfirm
              title="确定要删除这个设备吗？"
              @confirm="handleDelete(record)"
            >
              <a-button size="small" danger>删除</a-button>
            </a-popconfirm>
          </a-space>
        </template>
      </template>
    </a-table>
  
    <!-- 设备编辑弹窗 -->
    <DeviceModal
      v-model:visible="modalVisible"
      :device="currentDevice"
      @submit="handleModalSubmit"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue'
import { useDeviceStore } from '@/stores/modules/device'
import { useTable } from '@/composables/useTable'
import DeviceModal from './components/DeviceModal.vue'
import type { Device } from '@/types/global'

const deviceStore = useDeviceStore()
const { loading, pagination, handleTableChange } = useTable()

const searchForm = reactive({
  name: '',
  deviceType: undefined,
  status: undefined
})

const modalVisible = ref(false)
const currentDevice = ref<Device | null>(null)

// 表格列定义
const columns = [
  {
    title: '设备名称',
    dataIndex: 'name',
    key: 'name',
    sorter: true
  },
  {
    title: '设备ID',
    dataIndex: 'deviceId',
    key: 'deviceId'
  },
  {
    title: '设备类型',
    dataIndex: 'deviceType',
    key: 'deviceType',
    customRender: ({ text }) => {
      const typeMap = {
        'IPC': '网络摄像机',
        'NVR': '网络录像机',
        'DVR': '硬盘录像机'
      }
      return typeMap[text] || text
    }
  },
  {
    title: 'IP地址',
    dataIndex: 'ip',
    key: 'ip'
  },
  {
    title: '端口',
    dataIndex: 'port',
    key: 'port'
  },
  {
    title: '状态',
    key: 'status'
  },
  {
    title: '通道数',
    key: 'channelCount',
    customRender: ({ record }) => record.channels?.length || 0
  },
  {
    title: '创建时间',
    dataIndex: 'createTime',
    key: 'createTime',
    sorter: true
  },
  {
    title: '操作',
    key: 'actions',
    width: 200
  }
]

// 事件处理
const handleAdd = () => {
  currentDevice.value = null
  modalVisible.value = true
}

const handleEdit = (record: Device) => {
  currentDevice.value = record
  modalVisible.value = true
}

const handleView = (record: Device) => {
  // 跳转到设备详情页
  router.push(`/device/detail/${record.id}`)
}

const handleChannels = (record: Device) => {
  // 跳转到通道管理页
  router.push(`/device/channels/${record.id}`)
}

const handleDelete = async (record: Device) => {
  await deviceStore.deleteDevice(record.id)
  handleRefresh()
}

const handleRefresh = () => {
  deviceStore.loadDevices()
}

const handleSearch = () => {
  deviceStore.searchDevices(searchForm)
}

const handleReset = () => {
  Object.assign(searchForm, {
    name: '',
    deviceType: undefined,
    status: undefined
  })
  handleSearch()
}

const handleModalSubmit = async (device: Device) => {
  if (currentDevice.value) {
    await deviceStore.updateDevice(device.id, device)
  } else {
    await deviceStore.createDevice(device)
  }
  modalVisible.value = false
  handleRefresh()
}

onMounted(() => {
  handleRefresh()
})
</script>
```

### 3.2 视频播放模块

#### 3.2.1 智能播放器组件

```
<!-- src/components/business/VideoPlayer/index.vue -->
<template>
  <div class="video-player-container" :class="playerClass">
    <div class="player-wrapper" ref="playerRef">
      <!-- Jessibuca播放器 -->
      <div 
        v-if="currentPlayerType === 'jessibuca'" 
        :id="playerId" 
        class="jessibuca-player"
      ></div>
  
      <!-- H265Web.js播放器 -->
      <div 
        v-if="currentPlayerType === 'h265web'" 
        class="h265web-player"
      >
        <canvas :id="canvasId" ref="canvasRef"></canvas>
      </div>
  
      <!-- 播放器控制栏 -->
      <div class="player-controls" v-show="showControls">
        <div class="controls-left">
          <a-button 
            :type="isPlaying ? 'default' : 'primary'" 
            @click="togglePlay"
            size="small"
          >
            <template #icon>
              <PauseOutlined v-if="isPlaying" />
              <PlayCircleOutlined v-else />
            </template>
            {{ isPlaying ? '暂停' : '播放' }}
          </a-button>
    
          <a-button @click="handleStop" size="small">
            <template #icon><StopOutlined /></template>
            停止
          </a-button>
    
          <a-button @click="handleSnapshot" size="small">
            <template #icon><CameraOutlined /></template>
            截图
          </a-button>
    
          <a-button @click="toggleRecord" size="small">
            <template #icon><VideoCameraOutlined /></template>
            {{ isRecording ? '停止录像' : '开始录像' }}
          </a-button>
        </div>
  
        <div class="controls-center">
          <span class="stream-info">
            {{ streamInfo?.resolution }} | {{ streamInfo?.codec?.toUpperCase() }} | {{ streamInfo?.frameRate }}fps
          </span>
        </div>
  
        <div class="controls-right">
          <a-select 
            v-model:value="currentStreamType" 
            size="small" 
            @change="handleStreamChange"
            style="width: 100px"
          >
            <a-select-option value="main">主码流</a-select-option>
            <a-select-option value="sub">子码流</a-select-option>
          </a-select>
    
          <a-button @click="toggleFullscreen" size="small">
            <template #icon>
              <FullscreenExitOutlined v-if="isFullscreen" />
              <FullscreenOutlined v-else />
            </template>
          </a-button>
        </div>
      </div>
  
      <!-- 加载状态 -->
      <div v-show="loading" class="player-loading">
        <a-spin size="large" />
        <p>正在加载视频流...</p>
      </div>
  
      <!-- 错误状态 -->
      <div v-show="error" class="player-error">
        <ExclamationCircleOutlined class="error-icon" />
        <p>{{ error }}</p>
        <a-button @click="handleReplay">重新播放</a-button>
      </div>
    </div>
  
    <!-- 云台控制面板 -->
    <PTZControl 
      v-if="showPTZ && ptzEnabled" 
      :device-id="deviceId" 
      :channel-id="channelId"
      @command="handlePTZCommand"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, onUnmounted, nextTick } from 'vue'
import { usePlayer } from '@/composables/usePlayer'
import { useStreamStore } from '@/stores/modules/stream'
import { message } from 'ant-design-vue'
import PTZControl from '../PTZControl/index.vue'
import type { StreamProfile, PTZCommand } from '@/types/global'

interface Props {
  deviceId: string
  channelId: string
  streamType?: 'main' | 'sub'
  showControls?: boolean
  showPTZ?: boolean
  autoPlay?: boolean
  width?: string | number
  height?: string | number
}

const props = withDefaults(defineProps<Props>(), {
  streamType: 'main',
  showControls: true,
  showPTZ: false,
  autoPlay: true,
  width: '100%',
  height: '100%'
})

const streamStore = useStreamStore()

// 播放器实例管理
const {
  playerId,
  canvasId,
  playerRef,
  canvasRef,
  currentPlayerType,
  isPlaying,
  isRecording,
  isFullscreen,
  loading,
  error,
  initPlayer,
  startPlay,
  stopPlay,
  togglePlay,
  toggleRecord,
  toggleFullscreen,
  destroy
} = usePlayer()

const currentStreamType = ref(props.streamType)
const showControls = ref(props.showControls)
const streamInfo = ref<StreamProfile | null>(null)

// 计算属性
const playerClass = computed(() => ({
  'player-playing': isPlaying.value,
  'player-fullscreen': isFullscreen.value,
  'player-loading': loading.value,
  'player-error': !!error.value
}))

const ptzEnabled = computed(() => {
  return streamStore.getChannelPTZStatus(props.deviceId, props.channelId)
})

// 监听属性变化
watch([() => props.deviceId, () => props.channelId, currentStreamType], async () => {
  if (props.deviceId && props.channelId) {
    await loadStream()
  }
}, { immediate: true })

// 加载流信息
const loadStream = async () => {
  try {
    loading.value = true
    error.value = ''
  
    // 获取流信息
    streamInfo.value = await streamStore.getStreamProfile(
      props.deviceId, 
      props.channelId, 
      currentStreamType.value
    )
  
    if (!streamInfo.value) {
      throw new Error('无法获取流信息')
    }
  
    // 根据编解码格式选择播放器
    const playerType = streamInfo.value.codec === 'h265' ? 'h265web' : 'jessibuca'
  
    // 初始化播放器
    await initPlayer(playerType)
  
    // 开始播放
    if (props.autoPlay) {
      const streamUrl = getStreamUrl(streamInfo.value, playerType)
      await startPlay(streamUrl)
    }
  
  } catch (err) {
    error.value = err.message || '播放失败'
    message.error(error.value)
  } finally {
    loading.value = false
  }
}

// 获取流地址
const getStreamUrl = (stream: StreamProfile, playerType: string) => {
  if (playerType === 'h265web') {
    return stream.urls.hls // H265使用HLS
  } else {
    return stream.urls.wsflv // H264使用WebSocket-FLV
  }
}

// 事件处理
const handleStop = async () => {
  await stopPlay()
  streamStore.stopStream(props.deviceId, props.channelId)
}

const handleSnapshot = async () => {
  try {
    const imageData = await captureSnapshot()
    downloadImage(imageData, `snapshot_${props.deviceId}_${props.channelId}_${Date.now()}.jpg`)
    message.success('截图成功')
  } catch (err) {
    message.error('截图失败')
  }
}

const handleStreamChange = async (type: 'main' | 'sub') => {
  currentStreamType.value = type
  await loadStream()
}

const handleReplay = () => {
  loadStream()
}

const handlePTZCommand = (command: PTZCommand) => {
  streamStore.sendPTZCommand(props.deviceId, props.channelId, command)
}

// 截图功能
const captureSnapshot = async (): Promise<string> => {
  if (currentPlayerType.value === 'jessibuca') {
    // Jessibuca截图
    return new Promise((resolve, reject) => {
      const player = window[`jessibuca_${playerId.value}`]
      if (player && player.screenshot) {
        player.screenshot('image/jpeg', '', 'base64', (base64) => {
          resolve(base64)
        })
      } else {
        reject(new Error('播放器不支持截图'))
      }
    })
  } else if (currentPlayerType.value === 'h265web') {
    // H265Web.js截图
    const canvas = canvasRef.value
    if (canvas) {
      return canvas.toDataURL('image/jpeg')
    } else {
      throw new Error('无法获取画布')
    }
  }
  throw new Error('未知播放器类型')
}

// 下载图片
const downloadImage = (dataUrl: string, filename: string) => {
  const link = document.createElement('a')
  link.download = filename
  link.href = dataUrl
  link.click()
}

// 生命周期
onMounted(() => {
  if (props.deviceId && props.channelId) {
    loadStream()
  }
})

onUnmounted(() => {
  destroy()
})

// 暴露方法给父组件
defineExpose({
  startPlay: loadStream,
  stopPlay: handleStop,
  togglePlay,
  snapshot: handleSnapshot,
  switchStream: handleStreamChange
})
</script>

<style lang="scss" scoped>
.video-player-container {
  position: relative;
  width: 100%;
  height: 100%;
  background: #000;
  border-radius: 4px;
  overflow: hidden;

  .player-wrapper {
    position: relative;
    width: 100%;
    height: 100%;

    .jessibuca-player,
    .h265web-player {
      width: 100%;
      height: 100%;
    }

    .h265web-player canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  }

  .player-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
    color: white;
    opacity: 0;
    transition: opacity 0.3s;

    .controls-left,
    .controls-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .controls-center {
      flex: 1;
      text-align: center;

      .stream-info {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
      }
    }
  }

  &:hover .player-controls {
    opacity: 1;
  }

  .player-loading,
  .player-error {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: white;

    .error-icon {
      font-size: 48px;
      color: #ff4d4f;
      margin-bottom: 16px;
    }

    p {
      margin: 16px 0;
      font-size: 14px;
    }
  }

  &.player-fullscreen {
    position: fixed !important;
    top: 0;
    left: 0;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999;
  }
}
</style>
```

## 4. 状态管理设计 (Pinia Store)

状态管理设计：Pinia Store 结构、数据流、缓存策略

### 4.1 Store 架构设计

#### 4.1.1 用户状态管理

```
// src/stores/modules/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { userAPI } from '@/api/modules/user'
import { storage } from '@/utils/storage'
import type { User, LoginForm, UserPermission } from '@/types/global'

export const useUserStore = defineStore('user', () => {
  // 状态
  const user = ref<User | null>(null)
  const token = ref<string>('')
  const permissions = ref<UserPermission[]>([])
  const roles = ref<string[]>([])
  const isLoggedIn = ref(false)

  // 计算属性
  const userInfo = computed(() => user.value)
  const hasPermission = computed(() => (permission: string) => {
    return permissions.value.some(p => p.code === permission)
  })
  const hasRole = computed(() => (role: string) => {
    return roles.value.includes(role)
  })

  // Actions
  const login = async (loginForm: LoginForm) => {
    try {
      const response = await userAPI.login(loginForm)
      const { token: authToken, user: userData } = response.data
  
      // 保存token和用户信息
      token.value = authToken
      user.value = userData
      isLoggedIn.value = true
  
      // 持久化存储
      storage.setToken(authToken)
      storage.setUserInfo(userData)
  
      // 获取用户权限
      await getUserPermissions()
  
      return response
    } catch (error) {
      throw error
    }
  }

  const logout = async () => {
    try {
      await userAPI.logout()
    } catch (error) {
      console.error('Logout API failed:', error)
    } finally {
      // 清除状态
      user.value = null
      token.value = ''
      permissions.value = []
      roles.value = []
      isLoggedIn.value = false
  
      // 清除存储
      storage.clearAuth()
    }
  }

  const getUserPermissions = async () => {
    try {
      const response = await userAPI.getPermissions()
      permissions.value = response.data.permissions
      roles.value = response.data.roles
    } catch (error) {
      console.error('Get permissions failed:', error)
    }
  }

  const updateUserInfo = async (userInfo: Partial<User>) => {
    try {
      const response = await userAPI.updateProfile(userInfo)
      user.value = { ...user.value, ...response.data }
      storage.setUserInfo(user.value)
      return response
    } catch (error) {
      throw error
    }
  }

  const initializeAuth = () => {
    const savedToken = storage.getToken()
    const savedUser = storage.getUserInfo()
  
    if (savedToken && savedUser) {
      token.value = savedToken
      user.value = savedUser
      isLoggedIn.value = true
      getUserPermissions()
    }
  }

  return {
    // 状态
    user,
    token,
    permissions,
    roles,
    isLoggedIn,
    // 计算属性
    userInfo,
    hasPermission,
    hasRole,
    // Actions
    login,
    logout,
    getUserPermissions,
    updateUserInfo,
    initializeAuth
  }
})
```

#### 4.1.2 设备状态管理

```
// src/stores/modules/device.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { deviceAPI } from '@/api/modules/device'
import { useWebSocket } from '@/composables/useWebSocket'
import type { Device, DeviceChannel, DeviceFilter } from '@/types/global'

export const useDeviceStore = defineStore('device', () => {
  // 状态
  const devices = ref<Device[]>([])
  const selectedDevice = ref<Device | null>(null)
  const selectedChannel = ref<DeviceChannel | null>(null)
  const loading = ref(false)
  const filter = ref<DeviceFilter>({
    name: '',
    deviceType: '',
    status: '',
    page: 1,
    pageSize: 20
  })

  // 缓存映射
  const deviceMap = ref(new Map<string, Device>())
  const channelMap = ref(new Map<string, DeviceChannel>())

  // 计算属性
  const onlineDevices = computed(() => 
    devices.value.filter(device => device.status === 'online')
  )
  
  const offlineDevices = computed(() => 
    devices.value.filter(device => device.status === 'offline')
  )
  
  const deviceStats = computed(() => ({
    total: devices.value.length,
    online: onlineDevices.value.length,
    offline: offlineDevices.value.length,
    channels: devices.value.reduce((sum, device) => sum + (device.channels?.length || 0), 0)
  }))

  const filteredDevices = computed(() => {
    let result = devices.value
  
    if (filter.value.name) {
      result = result.filter(device => 
        device.name.toLowerCase().includes(filter.value.name.toLowerCase())
      )
    }
  
    if (filter.value.deviceType) {
      result = result.filter(device => device.deviceType === filter.value.deviceType)
    }
  
    if (filter.value.status) {
      result = result.filter(device => device.status === filter.value.status)
    }
  
    return result
  })

  // Actions
  const loadDevices = async (params?: Partial<DeviceFilter>) => {
    try {
      loading.value = true
      const searchParams = { ...filter.value, ...params }
      const response = await deviceAPI.getDevices(searchParams)
  
      devices.value = response.data.list
  
      // 更新缓存
      updateDeviceCache(devices.value)
  
      return response
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  const getDevice = async (deviceId: string): Promise<Device | null> => {
    // 先从缓存查找
    if (deviceMap.value.has(deviceId)) {
      return deviceMap.value.get(deviceId)!
    }
  
    // 从服务器获取
    try {
      const response = await deviceAPI.getDevice(deviceId)
      const device = response.data
  
      // 更新缓存
      deviceMap.value.set(deviceId, device)
  
      return device
    } catch (error) {
      console.error('Get device failed:', error)
      return null
    }
  }

  const createDevice = async (deviceData: Omit<Device, 'id' | 'createTime' | 'updateTime'>) => {
    const response = await deviceAPI.createDevice(deviceData)
    const newDevice = response.data
  
    devices.value.unshift(newDevice)
    deviceMap.value.set(newDevice.deviceId, newDevice)
  
    return response
  }

  const updateDevice = async (deviceId: string, deviceData: Partial<Device>) => {
    const response = await deviceAPI.updateDevice(deviceId, deviceData)
    const updatedDevice = response.data
  
    // 更新列表
    const index = devices.value.findIndex(d => d.id === deviceId)
    if (index !== -1) {
      devices.value[index] = updatedDevice
    }
  
    // 更新缓存
    deviceMap.value.set(updatedDevice.deviceId, updatedDevice)
  
    return response
  }

  const deleteDevice = async (deviceId: string) => {
    await deviceAPI.deleteDevice(deviceId)
  
    // 从列表中移除
    const index = devices.value.findIndex(d => d.id === deviceId)
    if (index !== -1) {
      const device = devices.value[index]
      devices.value.splice(index, 1)
      deviceMap.value.delete(device.deviceId)
    }
  }

  const updateDeviceStatus = (deviceId: string, status: 'online' | 'offline') => {
    const device = deviceMap.value.get(deviceId)
    if (device) {
      device.status = status
  
      // 更新列表中的设备状态
      const listDevice = devices.value.find(d => d.deviceId === deviceId)
      if (listDevice) {
        listDevice.status = status
      }
    }
  }

  const getDeviceChannels = async (deviceId: string): Promise<DeviceChannel[]> => {
    try {
      const response = await deviceAPI.getDeviceChannels(deviceId)
      const channels = response.data
  
      // 更新通道缓存
      channels.forEach(channel => {
        const channelKey = `${deviceId}_${channel.channelId}`
        channelMap.value.set(channelKey, channel)
      })
  
      return channels
    } catch (error) {
      console.error('Get device channels failed:', error)
      return []
    }
  }

  const selectDevice = (device: Device | null) => {
    selectedDevice.value = device
    selectedChannel.value = null
  }

  const selectChannel = (channel: DeviceChannel | null) => {
    selectedChannel.value = channel
  }

  const searchDevices = (searchFilter: Partial<DeviceFilter>) => {
    filter.value = { ...filter.value, ...searchFilter }
    return loadDevices()
  }

  const updateDeviceCache = (deviceList: Device[]) => {
    deviceMap.value.clear()
    deviceList.forEach(device => {
      deviceMap.value.set(device.deviceId, device)
  
      // 缓存通道信息
      device.channels?.forEach(channel => {
        const channelKey = `${device.deviceId}_${channel.channelId}`
        channelMap.value.set(channelKey, channel)
      })
    })
  }

  // WebSocket事件处理
  const { subscribe } = useWebSocket()
  
  // 监听设备状态变化
  subscribe('device-online', (data) => {
    updateDeviceStatus(data.deviceId, 'online')
  })
  
  subscribe('device-offline', (data) => {
    updateDeviceStatus(data.deviceId, 'offline')
  })

  return {
    // 状态
    devices,
    selectedDevice,
    selectedChannel,
    loading,
    filter,
    // 计算属性
    onlineDevices,
    offlineDevices,
    deviceStats,
    filteredDevices,
    // Actions
    loadDevices,
    getDevice,
    createDevice,
    updateDevice,
    deleteDevice,
    updateDeviceStatus,
    getDeviceChannels,
    selectDevice,
    selectChannel,
    searchDevices
  }
})
```

#### 4.1.3 流媒体状态管理

```
typescript// src/stores/modules/stream.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { streamAPI } from '@/api/modules/stream'
import type { StreamProfile, StreamSession, PTZCommand } from '@/types/global'

export const useStreamStore = defineStore('stream', () => {
  // 状态
  const activeStreams = ref<Map<string, StreamSession>>(new Map())
  const streamProfiles = ref<Map<string, StreamProfile>>(new Map())
  const loading = ref(false)

  // 计算属性
  const streamCount = computed(() => activeStreams.value.size)
  const totalBandwidth = computed(() => {
    let total = 0
    activeStreams.value.forEach(stream => {
      total += stream.bandwidth || 0
    })
    return total
  })

  // Actions
  const startStream = async (
    deviceId: string, 
    channelId: string, 
    streamType: 'main' | 'sub' = 'main'
  ): Promise<StreamProfile> => {
    try {
      loading.value = true
      const streamKey = `${deviceId}_${channelId}_${streamType}`
  
      // 检查是否已有活跃流
      if (activeStreams.value.has(streamKey)) {
        const session = activeStreams.value.get(streamKey)!
        return streamProfiles.value.get(streamKey)!
      }
  
      // 请求开始播放
      const response = await streamAPI.startPlay({
        deviceId,
        channelId,
        streamType
      })
  
      const streamProfile = response.data
  
      // 保存流信息
      streamProfiles.value.set(streamKey, streamProfile)
  
      // 创建流会话
      const session: StreamSession = {
        streamId: streamProfile.streamId,
        deviceId,
        channelId,
        streamType,
        status: 'playing',
        startTime: Date.now(),
        viewers: 1,
        bandwidth: streamProfile.bitRate
      }
  
      activeStreams.value.set(streamKey, session)
  
      return streamProfile
  
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }

  const stopStream = async (deviceId: string, channelId: string, streamType: 'main' | 'sub' = 'main') => {
    try {
      const streamKey = `${deviceId}_${channelId}_${streamType}`
  
      // 停止流
      await streamAPI.stopPlay({
        deviceId,
        channelId,
        streamType
      })
  
      // 清除状态
      activeStreams.value.delete(streamKey)
      streamProfiles.value.delete(streamKey)
  
    } catch (error) {
      console.error('Stop stream failed:', error)
    }
  }

  const getStreamProfile = async (
    deviceId: string, 
    channelId: string, 
    streamType: 'main' | 'sub' = 'main'
  ): Promise<StreamProfile | null> => {
    const streamKey = `${deviceId}_${channelId}_${streamType}`
  
    // 先从缓存获取
    if (streamProfiles.value.has(streamKey)) {
      return streamProfiles.value.get(streamKey)!
    }
  
    // 从服务器获取
    try {
      const response = await streamAPI.getStreamInfo({
        deviceId,
        channelId,
        streamType
      })
  
      const profile = response.data
      streamProfiles.value.set(streamKey, profile)
  
      return profile
    } catch (error) {
      console.error('Get stream profile failed:', error)
      return null
    }
  }

  const sendPTZCommand = async (
    deviceId: string, 
    channelId: string, 
    command: PTZCommand
  ) => {
    try {
      await streamAPI.sendPTZCommand({
        deviceId,
        channelId,
        command: command.command,
        parameter1: command.parameter1,
        parameter2: command.parameter2,
        parameter3: command.parameter3
      })
    } catch (error) {
      throw error
    }
  }

  const getChannelPTZStatus = (deviceId: string, channelId: string): boolean => {
    // 从设备store获取通道信息，判断是否支持云台
    const deviceStore = useDeviceStore()
    const device = deviceStore.deviceMap.get(deviceId)
    if (device && device.channels) {
      const channel = device.channels.find(c => c.channelId === channelId)
      return channel ? channel.ptzType > 0 : false
    }
    return false
  }

  const startRecord = async (deviceId: string, channelId: string) => {
    try {
      const response = await streamAPI.startRecord({
        deviceId,
        channelId
      })
  
      // 更新流会话状态
      const streamKey = `${deviceId}_${channelId}_main`
      const session = activeStreams.value.get(streamKey)
      if (session) {
        session.recording = true
        session.recordId = response.data.recordId
      }
  
      return response
    } catch (error) {
      throw error
    }
  }

  const stopRecord = async (deviceId: string, channelId: string) => {
    try {
      const streamKey = `${deviceId}_${channelId}_main`
      const session = activeStreams.value.get(streamKey)
  
      if (session && session.recordId) {
        await streamAPI.stopRecord({
          recordId: session.recordId
        })
  
        session.recording = false
        delete session.recordId
      }
    } catch (error) {
      throw error
    }
  }

  const getStreamStats = () => {
    const stats = {
      totalStreams: activeStreams.value.size,
      recordingStreams: 0,
      totalViewers: 0,
      totalBandwidth: 0
    }
  
    activeStreams.value.forEach(stream => {
      if (stream.recording) stats.recordingStreams++
      stats.totalViewers += stream.viewers || 0
      stats.totalBandwidth += stream.bandwidth || 0
    })
  
    return stats
  }

  const clearInactiveStreams = () => {
    const now = Date.now()
    const timeout = 30 * 60 * 1000 // 30分钟超时
  
    activeStreams.value.forEach((session, key) => {
      if (now - session.startTime > timeout && !session.recording) {
        activeStreams.value.delete(key)
        streamProfiles.value.delete(key)
      }
    })
  }

  return {
    // 状态
    activeStreams,
    streamProfiles,
    loading,
    // 计算属性
    streamCount,
    totalBandwidth,
    // Actions
    startStream,
    stopStream,
    getStreamProfile,
    sendPTZCommand,
    getChannelPTZStatus,
    startRecord,
    stopRecord,
    getStreamStats,
    clearInactiveStreams
  }
})
```

### 4.2 缓存策略设计

#### 4.2.1 本地存储管理

```
// src/utils/storage.ts
interface StorageData {
  token: string | null
  userInfo: any | null
  deviceCache: Map<string, any>
  streamCache: Map<string, any>
  appSettings: Record<string, any>
}

class StorageManager {
  private readonly TOKEN_KEY = 'gb28181_token'
  private readonly USER_KEY = 'gb28181_user'
  private readonly DEVICE_CACHE_KEY = 'gb28181_device_cache'
  private readonly STREAM_CACHE_KEY = 'gb28181_stream_cache'
  private readonly SETTINGS_KEY = 'gb28181_settings'
  
  // Token管理
  setToken(token: string) {
    localStorage.setItem(this.TOKEN_KEY, token)
  }
  
  getToken(): string | null {
    return localStorage.getItem(this.TOKEN_KEY)
  }
  
  removeToken() {
    localStorage.removeItem(this.TOKEN_KEY)
  }
  
  // 用户信息管理
  setUserInfo(user: any) {
    localStorage.setItem(this.USER_KEY, JSON.stringify(user))
  }
  
  getUserInfo(): any | null {
    const userStr = localStorage.getItem(this.USER_KEY)
    return userStr ? JSON.parse(userStr) : null
  }
  
  removeUserInfo() {
    localStorage.removeItem(this.USER_KEY)
  }
  
  // 设备缓存管理
  setDeviceCache(devices: Map<string, any>) {
    const data = Array.from(devices.entries())
    sessionStorage.setItem(this.DEVICE_CACHE_KEY, JSON.stringify(data))
  }
  
  getDeviceCache(): Map<string, any> {
    const dataStr = sessionStorage.getItem(this.DEVICE_CACHE_KEY)
    if (dataStr) {
      const data = JSON.parse(dataStr)
      return new Map(data)
    }
    return new Map()
  }
  
  // 流缓存管理
  setStreamCache(streams: Map<string, any>) {
    const data = Array.from(streams.entries())
    sessionStorage.setItem(this.STREAM_CACHE_KEY, JSON.stringify(data))
  }
  
  getStreamCache(): Map<string, any> {
    const dataStr = sessionStorage.getItem(this.STREAM_CACHE_KEY)
    if (dataStr) {
      const data = JSON.parse(dataStr)
      return new Map(data)
    }
    return new Map()
  }
  
  // 应用设置管理
  setSetting(key: string, value: any) {
    const settings = this.getSettings()
    settings[key] = value
    localStorage.setItem(this.SETTINGS_KEY, JSON.stringify(settings))
  }
  
  getSetting(key: string, defaultValue?: any) {
    const settings = this.getSettings()
    return settings[key] ?? defaultValue
  }
  
  getSettings(): Record<string, any> {
    const settingsStr = localStorage.getItem(this.SETTINGS_KEY)
    return settingsStr ? JSON.parse(settingsStr) : {}
  }
  
  // 清除认证信息
  clearAuth() {
    this.removeToken()
    this.removeUserInfo()
  }
  
  // 清除所有缓存
  clearAll() {
    localStorage.clear()
    sessionStorage.clear()
  }
}

export const storage = new StorageManager()
```

#### 4.2.2 数据流设计图

让我为您创建一个数据流设计图：

graph TD
A[前端组件] --> B[Pinia Store]
B --> C[API Layer]
C --> D[HTTP/WebSocket]
D --> E[后端服务]

```
B --> F[Local Storage]
B --> G[Session Storage]
B --> H[Memory Cache]

I[WebSocket Events] --> B

subgraph "Store Modules"
    J[User Store]
    K[Device Store]
    L[Stream Store]
    M[Record Store]
    N[System Store]
end

B --> J
B --> K
B --> L
B --> M
B --> N

subgraph "Cache Strategy"
    O[Token Cache]
    P[Device Cache]
    Q[Stream Cache]
    R[User Preferences]
end

F --> O
G --> P
G --> Q
F --> R

style A fill:#e1f5fe
style B fill:#f3e5f5
style E fill:#e8f5e8
style I fill:#fff3e0
```

## 5. 路由与页面设计

路由与页面设计：页面结构、权限控制、导航设计

### 5.1 路由配置

#### 5.1.1 路由主文件

```
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { setupRouterGuards } from './guards'
import { routes } from './routes'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition
    } else {
      return { top: 0 }
    }
  }
})

// 设置路由守卫
setupRouterGuards(router)

export default router
```

#### 5.1.2 路由配置文件

typescript

```
// src/router/routes.ts
import type { RouteRecordRaw } from 'vue-router'

// 布局组件懒加载
const DefaultLayout = () => import('@/layouts/DefaultLayout.vue')
const BlankLayout = () => import('@/layouts/BlankLayout.vue')
const PlayerLayout = () => import('@/layouts/PlayerLayout.vue')

export const routes: RouteRecordRaw[] = [
  // 登录路由
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/login/LoginView.vue'),
    meta: {
      title: '用户登录',
      requiresAuth: false,
      hideInMenu: true
    }
  },
  
  // 主应用路由
  {
    path: '/',
    component: DefaultLayout,
    redirect: '/dashboard',
    meta: {
      title: 'GB28181视频平台',
      requiresAuth: true
    },
    children: [
      // 仪表板
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/dashboard/DashboardView.vue'),
        meta: {
          title: '控制台',
          icon: 'DashboardOutlined',
          requiresAuth: true,
          keepAlive: true
        }
      },
  
      // 实时监控
      {
        path: 'monitor',
        name: 'Monitor',
        meta: {
          title: '实时监控',
          icon: 'VideoCameraOutlined',
          requiresAuth: true
        },
        children: [
          {
            path: 'live',
            name: 'LiveView',
            component: () => import('@/views/monitor/LiveView.vue'),
            meta: {
              title: '实时预览',
              requiresAuth: true,
              permissions: ['monitor:live:view']
            }
          },
          {
            path: 'multi',
            name: 'MultiView',
            component: () => import('@/views/monitor/MultiView.vue'),
            meta: {
              title: '多画面监控',
              requiresAuth: true,
              permissions: ['monitor:multi:view']
            }
          }
        ]
      },
  
      // 设备管理
      {
        path: 'device',
        name: 'Device',
        meta: {
          title: '设备管理',
          icon: 'CameraOutlined',
          requiresAuth: true
        },
        children: [
          {
            path: 'list',
            name: 'DeviceList',
            component: () => import('@/views/device/DeviceList.vue'),
            meta: {
              title: '设备列表',
              requiresAuth: true,
              permissions: ['device:list:view']
            }
          },
          {
            path: 'detail/:id',
            name: 'DeviceDetail',
            component: () => import('@/views/device/DeviceDetail.vue'),
            meta: {
              title: '设备详情',
              requiresAuth: true,
              hideInMenu: true,
              permissions: ['device:detail:view']
            }
          },
          {
            path: 'channels/:deviceId',
            name: 'ChannelList',
            component: () => import('@/views/device/ChannelList.vue'),
            meta: {
              title: '通道管理',
              requiresAuth: true,
              hideInMenu: true,
              permissions: ['device:channel:view']
            }
          }
        ]
      },
  
      // 录像回放
      {
        path: 'playback',
        name: 'Playback',
        meta: {
          title: '录像回放',
          icon: 'PlayCircleOutlined',
          requiresAuth: true
        },
        children: [
          {
            path: 'record',
            name: 'RecordList',
            component: () => import('@/views/playback/RecordList.vue'),
            meta: {
              title: '录像列表',
              requiresAuth: true,
              permissions: ['record:list:view']
            }
          },
          {
            path: 'play/:recordId',
            name: 'RecordPlay',
            component: () => import('@/views/playback/RecordPlay.vue'),
            meta: {
              title: '录像播放',
              requiresAuth: true,
              hideInMenu: true,
              permissions: ['record:play:view']
            }
          }
        ]
      },
  
      // 系统管理
      {
        path: 'system',
        name: 'System',
        meta: {
          title: '系统管理',
          icon: 'SettingOutlined',
          requiresAuth: true,
          roles: ['admin', 'manager']
        },
        children: [
          {
            path: 'user',
            name: 'UserManage',
            component: () => import('@/views/system/UserManage.vue'),
            meta: {
              title: '用户管理',
              requiresAuth: true,
              permissions: ['system:user:manage']
            }
          },
          {
            path: 'role',
            name: 'RoleManage',
            component: () => import('@/views/system/RoleManage.vue'),
            meta: {
              title: '角色管理',
              requiresAuth: true,
              permissions: ['system:role:manage']
            }
          },
          {
            path: 'config',
            name: 'ConfigManage',
            component: () => import('@/views/system/ConfigManage.vue'),
            meta: {
              title: '系统配置',
              requiresAuth: true,
              permissions: ['system:config:manage']
            }
          },
          {
            path: 'log',
            name: 'LogManage',
            component: () => import('@/views/system/LogManage.vue'),
            meta: {
              title: '日志管理',
              requiresAuth: true,
              permissions: ['system:log:view']
            }
          }
        ]
      }
    ]
  },
  
  // 全屏播放路由
  {
    path: '/player',
    component: PlayerLayout,
    children: [
      {
        path: 'fullscreen/:deviceId/:channelId',
        name: 'FullscreenPlayer',
        component: () => import('@/views/monitor/FullScreen.vue'),
        meta: {
          title: '全屏播放',
          requiresAuth: true,
          hideInMenu: true
        }
      }
    ]
  },
  
  // 异常页面
  {
    path: '/exception',
    component: BlankLayout,
    children: [
      {
        path: '403',
        name: 'Exception403',
        component: () => import('@/views/exception/403.vue'),
        meta: {
          title: '无权限',
          hideInMenu: true
        }
      },
      {
        path: '404',
        name: 'Exception404',
        component: () => import('@/views/exception/404.vue'),
        meta: {
          title: '页面不存在',
          hideInMenu: true
        }
      },
      {
        path: '500',
        name: 'Exception500',
        component: () => import('@/views/exception/500.vue'),
        meta: {
          title: '服务器错误',
          hideInMenu: true
        }
      }
    ]
  },
  
  // 404路由 - 必须放在最后
  {
    path: '/:pathMatch(.*)*',
    redirect: '/exception/404'
  }
]
```

#### 5.1.3 路由守卫

typescript

```
// src/router/guards.ts
import type { Router } from 'vue-router'
import { useUserStore } from '@/stores/modules/user'
import { message } from 'ant-design-vue'

export function setupRouterGuards(router: Router) {
  // 全局前置守卫
  router.beforeEach(async (to, from, next) => {
    const userStore = useUserStore()
  
    // 设置页面标题
    if (to.meta.title) {
      document.title = `${to.meta.title} - GB28181视频平台`
    }
  
    // 检查是否需要认证
    if (to.meta.requiresAuth) {
      if (!userStore.isLoggedIn) {
        // 未登录，跳转到登录页
        message.warning('请先登录')
        next({
          path: '/login',
          query: { redirect: to.fullPath }
        })
        return
      }
  
      // 检查权限
      if (to.meta.permissions && Array.isArray(to.meta.permissions)) {
        const hasPermission = to.meta.permissions.some(permission => 
          userStore.hasPermission(permission)
        )
  
        if (!hasPermission) {
          message.error('您没有访问该页面的权限')
          next('/exception/403')
          return
        }
      }
  
      // 检查角色
      if (to.meta.roles && Array.isArray(to.meta.roles)) {
        const hasRole = to.meta.roles.some(role => 
          userStore.hasRole(role)
        )
  
        if (!hasRole) {
          message.error('您的角色无法访问该页面')
          next('/exception/403')
          return
        }
      }
    }
  
    // 已登录状态下访问登录页，跳转到首页
    if (to.path === '/login' && userStore.isLoggedIn) {
      next('/')
      return
    }
  
    next()
  })
  
  // 全局后置守卫
  router.afterEach((to, from) => {
    // 页面访问统计
    if (to.name && typeof to.name === 'string') {
      console.log(`Page accessed: ${to.name}`)
    }
  })
}
```

### 5.2 导航设计

#### 5.2.1 侧边栏组件

####

```
<!-- src/components/common/AppSidebar/index.vue -->
<template>
  <a-layout-sider
    v-model:collapsed="collapsed"
    :trigger="null"
    collapsible
    :width="sidebarWidth"
    :collapsed-width="collapsedWidth"
    class="app-sidebar"
  >
    <!-- Logo区域 -->
    <div class="sidebar-logo">
      <img src="@/assets/images/logo.png" alt="Logo" class="logo-img" />
      <h1 v-show="!collapsed" class="logo-title">GB28181平台</h1>
    </div>
  
    <!-- 菜单区域 -->
    <a-menu
      v-model:selectedKeys="selectedKeys"
      v-model:openKeys="openKeys"
      mode="inline"
      theme="dark"
      :inline-collapsed="collapsed"
      @click="handleMenuClick"
    >
      <template v-for="route in menuRoutes" :key="route.path">
        <a-menu-item v-if="!route.children" :key="route.path">
          <template #icon>
            <component :is="route.meta.icon" />
          </template>
          <span>{{ route.meta.title }}</span>
        </a-menu-item>
  
        <a-sub-menu v-else :key="route.path">
          <template #icon>
            <component :is="route.meta.icon" />
          </template>
          <template #title>{{ route.meta.title }}</template>
    
          <a-menu-item 
            v-for="child in route.children.filter(c => !c.meta?.hideInMenu)" 
            :key="child.path"
          >
            {{ child.meta.title }}
          </a-menu-item>
        </a-sub-menu>
      </template>
    </a-menu>
  
    <!-- 底部折叠按钮 -->
    <div class="sidebar-trigger" @click="toggleCollapsed">
      <MenuFoldOutlined v-if="!collapsed" />
      <MenuUnfoldOutlined v-else />
    </div>
  </a-layout-sider>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { useUserStore } from '@/stores/modules/user'
import { routes } from '@/router/routes'
import type { RouteRecordRaw } from 'vue-router'

const router = useRouter()
const route = useRoute()
const userStore = useUserStore()

// 侧边栏状态
const collapsed = ref(false)
const sidebarWidth = 240
const collapsedWidth = 80

const selectedKeys = ref<string[]>([])
const openKeys = ref<string[]>([])

// 过滤菜单路由
const menuRoutes = computed(() => {
  return filterMenuRoutes(routes)
})

// 过滤有权限的菜单路由
const filterMenuRoutes = (routes: RouteRecordRaw[]): RouteRecordRaw[] => {
  return routes.filter(route => {
    // 过滤隐藏菜单项
    if (route.meta?.hideInMenu) return false
  
    // 检查是否需要认证
    if (route.meta?.requiresAuth && !userStore.isLoggedIn) return false
  
    // 检查权限
    if (route.meta?.permissions && Array.isArray(route.meta.permissions)) {
      const hasPermission = route.meta.permissions.some(permission => 
        userStore.hasPermission(permission)
      )
      if (!hasPermission) return false
    }
  
    // 检查角色
    if (route.meta?.roles && Array.isArray(route.meta.roles)) {
      const hasRole = route.meta.roles.some(role => 
        userStore.hasRole(role)
      )
      if (!hasRole) return false
    }
  
    // 递归过滤子路由
    if (route.children) {
      route.children = filterMenuRoutes(route.children)
    }
  
    return true
  })
}

// 监听路由变化，更新菜单选中状态
watch(() => route.path, (newPath) => {
  updateMenuState(newPath)
}, { immediate: true })

const updateMenuState = (path: string) => {
  selectedKeys.value = [path]
  
  // 设置展开的菜单项
  const pathSegments = path.split('/').filter(Boolean)
  const openKeysList: string[] = []
  
  for (let i = 0; i < pathSegments.length; i++) {
    const currentPath = '/' + pathSegments.slice(0, i + 1).join('/')
    openKeysList.push(currentPath)
  }
  
  openKeys.value = openKeysList
}

// 菜单点击处理
const handleMenuClick = ({ key }: { key: string }) => {
  if (key !== route.path) {
    router.push(key)
  }
}

// 切换折叠状态
const toggleCollapsed = () => {
  collapsed.value = !collapsed.value
}

// 暴露给父组件
defineExpose({
  collapsed,
  toggleCollapsed
})
</script>

<style lang="scss" scoped>
.app-sidebar {
  height: 100vh;
  position: fixed;
  left: 0;
  top: 0;
  z-index: 100;
  box-shadow: 2px 0 6px rgba(0, 21, 41, 0.35);

  .sidebar-logo {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 64px;
    padding: 16px;
    background: rgba(255, 255, 255, 0.1);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);

    .logo-img {
      width: 32px;
      height: 32px;
    }

    .logo-title {
      margin: 0 0 0 12px;
      color: white;
      font-size: 16px;
      font-weight: 600;
      white-space: nowrap;
    }
  }

  .sidebar-trigger {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    cursor: pointer;
    color: white;
    transition: all 0.3s;

    &:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  }

  :deep(.ant-menu) {
    background: transparent;
    border-right: none;

    .ant-menu-item,
    .ant-menu-submenu-title {
      height: 48px;
      line-height: 48px;
      margin: 0;
      border-radius: 0;
    }

    .ant-menu-item-selected {
      background: #1890ff !important;
    }
  }
}
</style>
```

#### 5.2.2 页面头部组件

vue

```
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { setupRouterGuards } from './guards'
import { routes } from './routes'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition
    } else {
      return { top: 0 }
    }
  }
})

// 设置路由守卫
setupRouterGuards(router)

export default router
```

## 6. API接口设计

API接口设计：HTTP客户端、WebSocket通信、错误处理

### 6.1 HTTP客户端封装

#### 6.1.1 请求客户端

```
// src/api/request.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
import { message } from 'ant-design-vue'
import { useUserStore } from '@/stores/modules/user'
import { storage } from '@/utils/storage'
import router from '@/router'

// 响应数据接口
export interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
  timestamp: number
}

// 请求配置接口
export interface RequestConfig extends AxiosRequestConfig {
  skipAuth?: boolean
  skipErrorHandler?: boolean
  showLoading?: boolean
  showSuccessMessage?: boolean
}

class RequestClient {
  private instance: AxiosInstance
  private loadingCount = 0

  constructor() {
    this.instance = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    })

    this.setupInterceptors()
  }

  private setupInterceptors() {
    // 请求拦截器
    this.instance.interceptors.request.use(
      (config: RequestConfig) => {
        // 添加认证token
        if (!config.skipAuth) {
          const token = storage.getToken()
          if (token) {
            config.headers = config.headers || {}
            config.headers.Authorization = `Bearer ${token}`
          }
        }

        // 显示加载状态
        if (config.showLoading) {
          this.showLoading()
        }

        // 添加请求时间戳，防止缓存
        if (config.method === 'get') {
          config.params = {
            ...config.params,
            _t: Date.now()
          }
        }

        return config
      },
      (error) => {
        return Promise.reject(error)
      }
    )

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response: AxiosResponse<ApiResponse>) => {
        this.hideLoading()

        const { data } = response
        const config = response.config as RequestConfig

        // 显示成功消息
        if (config.showSuccessMessage && data.message) {
          message.success(data.message)
        }

        // 统一处理业务错误
        if (data.code !== 200) {
          if (!config.skipErrorHandler) {
            this.handleBusinessError(data.code, data.message)
          }
          return Promise.reject(new Error(data.message))
        }

        return response
      },
      (error) => {
        this.hideLoading()

        const config = error.config as RequestConfig
  
        if (!config?.skipErrorHandler) {
          this.handleHttpError(error)
        }

        return Promise.reject(error)
      }
    )
  }

  private showLoading() {
    this.loadingCount++
    // 这里可以显示全局loading
  }

  private hideLoading() {
    this.loadingCount--
    if (this.loadingCount <= 0) {
      this.loadingCount = 0
      // 这里可以隐藏全局loading
    }
  }

  private handleBusinessError(code: number, msg: string) {
    switch (code) {
      case 401:
        message.error('登录已过期，请重新登录')
        this.handleLogout()
        break
      case 403:
        message.error('没有权限访问该资源')
        break
      case 404:
        message.error('请求的资源不存在')
        break
      case 500:
        message.error('服务器内部错误')
        break
      default:
        message.error(msg || '请求失败')
    }
  }

  private handleHttpError(error: any) {
    if (error.response) {
      const { status, statusText } = error.response
      switch (status) {
        case 401:
          this.handleLogout()
          break
        case 403:
          router.push('/exception/403')
          break
        case 404:
          router.push('/exception/404')
          break
        case 500:
          router.push('/exception/500')
          break
        default:
          message.error(`请求失败: ${status} ${statusText}`)
      }
    } else if (error.request) {
      message.error('网络连接失败，请检查网络设置')
    } else {
      message.error('请求配置错误')
    }
  }

  private handleLogout() {
    const userStore = useUserStore()
    userStore.logout().then(() => {
      router.push('/login')
    })
  }

  // 通用请求方法
  public request<T = any>(config: RequestConfig): Promise<ApiResponse<T>> {
    return this.instance.request<any, AxiosResponse<ApiResponse<T>>>(config)
      .then(response => response.data)
  }

  // GET请求
  public get<T = any>(
    url: string, 
    params?: any, 
    config?: RequestConfig
  ): Promise<ApiResponse<T>> {
    return this.request<T>({
      method: 'GET',
      url,
      params,
      ...config
    })
  }

  // POST请求
  public post<T = any>(
    url: string, 
    data?: any, 
    config?: RequestConfig
  ): Promise<ApiResponse<T>> {
    return this.request<T>({
      method: 'POST',
      url,
      data,
      ...config
    })
  }

  // PUT请求
  public put<T = any>(
    url: string, 
    data?: any, 
    config?: RequestConfig
  ): Promise<ApiResponse<T>> {
    return this.request<T>({
      method: 'PUT',
      url,
      data,
      ...config
    })
  }

  // DELETE请求
  public delete<T = any>(
    url: string, 
    config?: RequestConfig
  ): Promise<ApiResponse<T>> {
    return this.request<T>({
      method: 'DELETE',
      url,
      ...config
    })
  }

  // 文件上传
  public upload<T = any>(
    url: string, 
    file: File, 
    onProgress?: (progress: number) => void,
    config?: RequestConfig
  ): Promise<ApiResponse<T>> {
    const formData = new FormData()
    formData.append('file', file)

    return this.request<T>({
      method: 'POST',
      url,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data'
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = (progressEvent.loaded / progressEvent.total) * 100
          onProgress(Math.round(progress))
        }
      },
      ...config
    })
  }

  // 文件下载
  public download(url: string, filename?: string, config?: RequestConfig): Promise<void> {
    return this.request({
      method: 'GET',
      url,
      responseType: 'blob',
      ...config
    }).then((response: any) => {
      const blob = new Blob([response])
      const downloadUrl = window.URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = downloadUrl
      link.download = filename || 'download'
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      window.URL.revokeObjectURL(downloadUrl)
    })
  }
}

export const httpClient = new RequestClient()
```

#### 6.1.2 API模块定义

typescript

```
// src/api/modules/device.ts
import { httpClient } from '../request'
import type { Device, DeviceChannel, DeviceFilter } from '@/types/global'

export interface DeviceListResponse {
  list: Device[]
  total: number
  page: number
  pageSize: number
}

export interface DeviceCreateRequest {
  deviceId: string
  name: string
  deviceType: 'IPC' | 'NVR' | 'DVR'
  ip: string
  port: number
  sipId?: string
  password?: string
}

export interface DeviceUpdateRequest extends Partial<DeviceCreateRequest> {}

export const deviceAPI = {
  // 获取设备列表
  getDevices: (params: DeviceFilter) => 
    httpClient.get<DeviceListResponse>('/devices', params),

  // 获取设备详情
  getDevice: (deviceId: string) => 
    httpClient.get<Device>(`/devices/${deviceId}`),

  // 创建设备
  createDevice: (data: DeviceCreateRequest) => 
    httpClient.post<Device>('/devices', data, { showSuccessMessage: true }),

  // 更新设备
  updateDevice: (deviceId: string, data: DeviceUpdateRequest) => 
    httpClient.put<Device>(`/devices/${deviceId}`, data, { showSuccessMessage: true }),

  // 删除设备
  deleteDevice: (deviceId: string) => 
    httpClient.delete(`/devices/${deviceId}`, { showSuccessMessage: true }),

  // 获取设备通道
  getDeviceChannels: (deviceId: string) => 
    httpClient.get<DeviceChannel[]>(`/devices/${deviceId}/channels`),

  // 同步设备通道
  syncDeviceChannels: (deviceId: string) => 
    httpClient.post(`/devices/${deviceId}/sync-channels`, {}, { 
      showLoading: true, 
      showSuccessMessage: true 
    }),

  // 设备控制
  controlDevice: (deviceId: string, action: 'reboot' | 'reset') => 
    httpClient.post(`/devices/${deviceId}/control`, { action }, { 
      showSuccessMessage: true 
    }),

  // 获取设备统计
  getDeviceStats: () => 
    httpClient.get('/devices/stats')
}
```

### 6.2 WebSocket通信设计

#### 6.2.1 WebSocket客户端

```
// src/api/websocket.ts
import { ref, reactive } from 'vue'
import { message } from 'ant-design-vue'
import { storage } from '@/utils/storage'

export interface WSMessage {
  type: string
  data: any
  timestamp: number
}

export interface WSConfig {
  url?: string
  protocols?: string | string[]
  reconnectInterval?: number
  maxReconnectAttempts?: number
  heartbeatInterval?: number
  enableHeartbeat?: boolean
}

export type WSEventHandler = (data: any) => void

class WebSocketClient {
  private ws: WebSocket | null = null
  private config: Required<WSConfig>
  private reconnectTimer: NodeJS.Timeout | null = null
  private heartbeatTimer: NodeJS.Timeout | null = null
  private eventHandlers: Map<string, WSEventHandler[]> = new Map()
  private reconnectAttempts = 0

  // 响应式状态
  public connected = ref(false)
  public connecting = ref(false)
  public lastError = ref<string>('')
  public stats = reactive({
    messagesReceived: 0,
    messagesSent: 0,
    reconnectCount: 0,
    lastHeartbeat: 0
  })

  constructor(config: WSConfig = {}) {
    this.config = {
      url: config.url || this.getDefaultWSUrl(),
      protocols: config.protocols || [],
      reconnectInterval: config.reconnectInterval || 3000,
      maxReconnectAttempts: config.maxReconnectAttempts || 10,
      heartbeatInterval: config.heartbeatInterval || 30000,
      enableHeartbeat: config.enableHeartbeat !== false
    }
  }

  private getDefaultWSUrl(): string {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
    const host = import.meta.env.VITE_WS_BASE_URL || window.location.host
    return `${protocol}//${host}/ws`
  }

  // 连接WebSocket
  public connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        resolve()
        return
      }

      this.connecting.value = true
      this.lastError.value = ''

      try {
        // 添加认证token到URL
        const token = storage.getToken()
        const wsUrl = token 
          ? `${this.config.url}?token=${encodeURIComponent(token)}`
          : this.config.url

        this.ws = new WebSocket(wsUrl, this.config.protocols)

        this.ws.onopen = (event) => {
          console.log('WebSocket连接成功', event)
          this.connected.value = true
          this.connecting.value = false
          this.reconnectAttempts = 0
    
          // 启动心跳
          if (this.config.enableHeartbeat) {
            this.startHeartbeat()
          }

          resolve()
        }

        this.ws.onmessage = (event) => {
          this.handleMessage(event.data)
        }

        this.ws.onclose = (event) => {
          console.log('WebSocket连接关闭', event)
          this.connected.value = false
          this.connecting.value = false
          this.stopHeartbeat()

          // 如果不是主动关闭，尝试重连
          if (event.code !== 1000 && this.reconnectAttempts < this.config.maxReconnectAttempts) {
            this.scheduleReconnect()
          }
        }

        this.ws.onerror = (event) => {
          console.error('WebSocket连接错误', event)
          this.lastError.value = 'WebSocket连接错误'
          this.connected.value = false
          this.connecting.value = false
          reject(new Error('WebSocket连接失败'))
        }

      } catch (error) {
        this.connecting.value = false
        this.lastError.value = error.message
        reject(error)
      }
    })
  }

  // 断开连接
  public disconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }

    this.stopHeartbeat()

    if (this.ws) {
      this.ws.close(1000, '主动断开')
      this.ws = null
    }

    this.connected.value = false
    this.connecting.value = false
  }

  // 发送消息
  public send(type: string, data?: any): boolean {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.warn('WebSocket未连接，无法发送消息')
      return false
    }

    try {
      const message: WSMessage = {
        type,
        data: data || {},
        timestamp: Date.now()
      }

      this.ws.send(JSON.stringify(message))
      this.stats.messagesSent++
      return true
    } catch (error) {
      console.error('发送WebSocket消息失败', error)
      return false
    }
  }

  // 订阅事件
  public subscribe(eventType: string, handler: WSEventHandler): () => void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, [])
    }

    this.eventHandlers.get(eventType)!.push(handler)

    // 返回取消订阅函数
    return () => {
      const handlers = this.eventHandlers.get(eventType)
      if (handlers) {
        const index = handlers.indexOf(handler)
        if (index !== -1) {
          handlers.splice(index, 1)
        }
      }
    }
  }

  // 取消订阅
  public unsubscribe(eventType: string, handler?: WSEventHandler): void {
    if (!handler) {
      // 取消所有该类型的订阅
      this.eventHandlers.delete(eventType)
      return
    }

    const handlers = this.eventHandlers.get(eventType)
    if (handlers) {
      const index = handlers.indexOf(handler)
      if (index !== -1) {
        handlers.splice(index, 1)
      }
    }
  }

  // 处理收到的消息
  private handleMessage(rawData: string): void {
    try {
      const message: WSMessage = JSON.parse(rawData)
      this.stats.messagesReceived++

      // 处理心跳响应
      if (message.type === 'pong') {
        this.stats.lastHeartbeat = Date.now()
        return
      }

      // 分发事件
      const handlers = this.eventHandlers.get(message.type)
      if (handlers && handlers.length > 0) {
        handlers.forEach(handler => {
          try {
            handler(message.data)
          } catch (error) {
            console.error(`处理WebSocket事件 ${message.type} 时出错`, error)
          }
        })
      } else {
        console.warn(`未找到WebSocket事件 ${message.type} 的处理器`)
      }

    } catch (error) {
      console.error('解析WebSocket消息失败', error, rawData)
    }
  }

  // 计划重连
  private scheduleReconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
    }

    this.reconnectAttempts++
    this.stats.reconnectCount++

    const delay = Math.min(
      this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1),
      30000 // 最大30秒
    )

    console.log(`WebSocket将在 ${delay}ms 后尝试第 ${this.reconnectAttempts} 次重连`)

    this.reconnectTimer = setTimeout(() => {
      this.connect().catch(error => {
        console.error('WebSocket重连失败', error)
      })
    }, delay)
  }

  // 启动心跳
  private startHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
    }

    this.heartbeatTimer = setInterval(() => {
      if (this.connected.value) {
        this.send('ping')
      }
    }, this.config.heartbeatInterval)
  }

  // 停止心跳
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }

  // 获取连接状态
  public getStatus() {
    return {
      connected: this.connected.value,
      connecting: this.connecting.value,
      readyState: this.ws?.readyState,
      lastError: this.lastError.value,
      stats: { ...this.stats }
    }
  }
}

// 创建全局WebSocket实例
export const wsClient = new WebSocketClient()

// 自动连接（如果已登录）
if (storage.getToken()) {
  wsClient.connect().catch(error => {
    console.error('WebSocket自动连接失败', error)
  })
}
```

#### 6.2.2 WebSocket Composable

typescript

```
// src/composables/useWebSocket.ts
import { onUnmounted } from 'vue'
import { wsClient, type WSEventHandler } from '@/api/websocket'

export function useWebSocket() {
  const unsubscribeFunctions: (() => void)[] = []

  // 订阅事件
  const subscribe = (eventType: string, handler: WSEventHandler) => {
    const unsubscribe = wsClient.subscribe(eventType, handler)
    unsubscribeFunctions.push(unsubscribe)
    return unsubscribe
  }

  // 发送消息
  const send = (type: string, data?: any) => {
    return wsClient.send(type, data)
  }

  // 连接WebSocket
  const connect = () => {
    return wsClient.connect()
  }

  // 断开连接
  const disconnect = () => {
    wsClient.disconnect()
  }

  // 获取连接状态
  const getStatus = () => {
    return wsClient.getStatus()
  }

  // 组件卸载时自动取消所有订阅
  onUnmounted(() => {
    unsubscribeFunctions.forEach(unsubscribe => unsubscribe())
  })

  return {
    subscribe,
    send,
    connect,
    disconnect,
    getStatus,
    connected: wsClient.connected,
    connecting: wsClient.connecting,
    stats: wsClient.stats
  }
}
```

### 6.3 错误处理机制

#### 6.3.1 全局错误处理

```
// src/utils/errorHandler.ts
import { message, notification } from 'ant-design-vue'
import { useUserStore } from '@/stores/modules/user'
import router from '@/router'

export interface ErrorInfo {
  message: string
  stack?: string
  componentStack?: string
  errorBoundary?: string
}

export interface ErrorReport {
  error: Error
  errorInfo: ErrorInfo
  url: string
  userAgent: string
  timestamp: number
  userId?: string
}

class ErrorHandler {
  private errorQueue: ErrorReport[] = []
  private maxQueueSize = 100

  // 处理Vue错误
  public handleVueError(error: Error, instance: any, info: string) {
    console.error('Vue Error:', error, info)
  
    const errorReport: ErrorReport = {
      error,
      errorInfo: {
        message: error.message,
        stack: error.stack,
        componentStack: info
      },
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    }

    this.reportError(errorReport)
    this.showErrorMessage(error.message)
  }

  // 处理全局未捕获错误
  public handleGlobalError(event: ErrorEvent) {
    console.error('Global Error:', event.error)
  
    const errorReport: ErrorReport = {
      error: event.error || new Error(event.message),
      errorInfo: {
        message: event.message,
        stack: event.error?.stack
      },
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    }

    this.reportError(errorReport)
    this.showErrorMessage('系统发生未知错误')
  }

  // 处理Promise未捕获拒绝
  public handleUnhandledRejection(event: PromiseRejectionEvent) {
    console.error('Unhandled Promise Rejection:', event.reason)
  
    const error = event.reason instanceof Error 
      ? event.reason 
      : new Error(String(event.reason))

    const errorReport: ErrorReport = {
      error,
      errorInfo: {
        message: error.message,
        stack: error.stack
      },
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    }

    this.reportError(errorReport)
  
    // 防止错误被打印到控制台
    event.preventDefault()
  }

  // 处理API错误
  public handleApiError(error: any, context?: string) {
    console.error('API Error:', error, context)
  
    let errorMessage = '请求失败'
  
    if (error.response) {
      const { status, data } = error.response
      errorMessage = data?.message || `请求失败 (${status})`
  
      // 特殊状态码处理
      switch (status) {
        case 401:
          this.handleAuthError()
          return
        case 403:
          errorMessage = '没有权限访问该资源'
          break
        case 404:
          errorMessage = '请求的资源不存在'
          break
        case 500:
          errorMessage = '服务器内部错误'
          break
      }
    } else if (error.request) {
      errorMessage = '网络连接失败'
    } else {
      errorMessage = error.message || '未知错误'
    }

    this.showErrorMessage(errorMessage, context)
  }

  // 处理认证错误
  private handleAuthError() {
    const userStore = useUserStore()
  
    notification.error({
      message: '认证失败',
      description: '登录已过期，请重新登录',
      duration: 3
    })

    userStore.logout().then(() => {
      router.push('/login')
    })
  }

  // 显示错误消息
  private showErrorMessage(errorMessage: string, context?: string) {
    const fullMessage = context ? `${context}: ${errorMessage}` : errorMessage
    message.error(fullMessage)
  }

  // 上报错误
  private reportError(errorReport: ErrorReport) {
    // 添加用户信息
    const userStore = useUserStore()
    errorReport.userId = userStore.userInfo?.id

    // 添加到队列
    this.errorQueue.push(errorReport)
  
    // 限制队列大小
    if (this.errorQueue.length > this.maxQueueSize) {
      this.errorQueue.shift()
    }

    // 异步上报（可选）
    this.sendErrorReport(errorReport).catch(error => {
      console.error('Error reporting failed:', error)
    })
  }

  // 发送错误报告到服务器
  private async sendErrorReport(errorReport: ErrorReport) {
    try {
      // 这里可以发送到错误监控服务
      await fetch('/api/errors/report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorReport)
      })
    } catch (error) {
      // 上报失败不应该影响用户体验
      console.warn('Failed to report error:', error)
    }
  }

  // 获取错误队列
  public getErrorQueue() {
    return [...this.errorQueue]
  }

  // 清空错误队列
  public clearErrorQueue() {
    this.errorQueue = []
  }
}

export const errorHandler = new ErrorHandler()

// 设置全局错误处理
export function setupErrorHandler(app: any) {
  // Vue错误处理
  app.config.errorHandler = (error: Error, instance: any, info: string) => {
    errorHandler.handleVueError(error, instance, info)
  }

  // 全局未捕获错误
  window.addEventListener('error', (event) => {
    errorHandler.handleGlobalError(event)
  })

  // Promise未捕获拒绝
  window.addEventListener('unhandledrejection', (event) => {
    errorHandler.handleUnhandledRejection(event)
  })
}
```

## 7. 播放器组件设计

### 7.1 播放器管理 Composable

#### 7.1.1 播放器管理核心

播放器组件设计：Jessibuca + H265Web.js 双播放器方案

```
// src/composables/usePlayer.ts
import { ref, computed, onUnmounted, nextTick } from 'vue'
import { message } from 'ant-design-vue'

export type PlayerType = 'jessibuca' | 'h265web'
export type PlayerStatus = 'idle' | 'loading' | 'playing' | 'paused' | 'error'

export interface PlayerConfig {
  container: string | HTMLElement
  width?: number | string
  height?: number | string
  autoPlay?: boolean
  muted?: boolean
  hasAudio?: boolean
  videoBuffer?: number
  videoBufferDelay?: number
  decoder?: string
  forceNoOffscreen?: boolean
  isResize?: boolean
  loadingTimeout?: number
  heartTimeout?: number
  timeout?: number
  pageVisibilityHiddenTimeout?: number
  debug?: boolean
}

export interface StreamURLs {
  rtsp?: string
  rtmp?: string
  flv?: string
  hls?: string
  wsflv?: string
}

export function usePlayer() {
  // 播放器实例引用
  const playerInstance = ref<any>(null)
  const playerRef = ref<HTMLElement>()
  const canvasRef = ref<HTMLCanvasElement>()
  
  // 播放器状态
  const currentPlayerType = ref<PlayerType>('jessibuca')
  const playerStatus = ref<PlayerStatus>('idle')
  const isPlaying = ref(false)
  const isRecording = ref(false)
  const isFullscreen = ref(false)
  const loading = ref(false)
  const error = ref('')
  
  // 播放器信息
  const playerId = ref(`player_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`)
  const canvasId = ref(`canvas_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`)
  const streamInfo = ref<any>(null)
  
  // 播放器配置
  const defaultConfig: PlayerConfig = {
    container: '',
    autoPlay: true,
    muted: false,
    hasAudio: true,
    videoBuffer: 0.2,
    videoBufferDelay: 1,
    isResize: true,
    loadingTimeout: 10,
    heartTimeout: 10,
    timeout: 10,
    pageVisibilityHiddenTimeout: 300,
    debug: false
  }

  // 计算属性
  const canPlay = computed(() => 
    playerStatus.value === 'idle' || playerStatus.value === 'paused'
  )
  
  const canPause = computed(() => 
    playerStatus.value === 'playing'
  )

  // 初始化播放器
  const initPlayer = async (type: PlayerType, config?: Partial<PlayerConfig>) => {
    try {
      currentPlayerType.value = type
      loading.value = true
      error.value = ''
  
      // 先销毁现有播放器
      if (playerInstance.value) {
        destroy()
      }
  
      // 等待DOM更新
      await nextTick()
  
      const mergedConfig = { ...defaultConfig, ...config }
  
      if (type === 'jessibuca') {
        await initJessibucaPlayer(mergedConfig)
      } else if (type === 'h265web') {
        await initH265WebPlayer(mergedConfig)
      } else {
        throw new Error(`不支持的播放器类型: ${type}`)
      }
  
      playerStatus.value = 'idle'
  
    } catch (err) {
      error.value = err.message || '播放器初始化失败'
      playerStatus.value = 'error'
      throw err
    } finally {
      loading.value = false
    }
  }

  // 初始化Jessibuca播放器
  const initJessibucaPlayer = async (config: PlayerConfig) => {
    // 确保Jessibuca已加载
    if (!window.Jessibuca) {
      throw new Error('Jessibuca播放器未加载')
    }
  
    const container = typeof config.container === 'string' 
      ? document.getElementById(config.container) || playerRef.value
      : config.container || playerRef.value
  
    if (!container) {
      throw new Error('播放器容器不存在')
    }

    playerInstance.value = new window.Jessibuca({
      container,
      videoBuffer: config.videoBuffer,
      videoBufferDelay: config.videoBufferDelay,
      decoder: config.decoder || '/players/jessibuca/decoder.wasm',
      forceNoOffscreen: config.forceNoOffscreen || false,
      isResize: config.isResize,
      loadingTimeout: config.loadingTimeout! * 1000,
      heartTimeout: config.heartTimeout! * 1000,
      timeout: config.timeout! * 1000,
      pageVisibilityHiddenTimeout: config.pageVisibilityHiddenTimeout! * 1000,
      debug: config.debug,
  
      // 事件回调
      onPlay: handlePlay,
      onPause: handlePause,
      onTimeUpdate: handleTimeUpdate,
      onMute: handleMute,
      onLoad: handleLoad,
      onLog: handleLog,
      onError: handleError,
      onKBps: handleKBps,
      onRecord: handleRecord,
      onBuffer: handleBuffer,
      onResolutionChange: handleResolutionChange
    })
  }

  // 初始化H265Web.js播放器
  const initH265WebPlayer = async (config: PlayerConfig) => {
    // 确保H265Web.js已加载
    if (!window.H265webjs) {
      throw new Error('H265Web.js播放器未加载')
    }
  
    const canvas = canvasRef.value
    if (!canvas) {
      throw new Error('Canvas元素不存在')
    }

    playerInstance.value = new window.H265webjs.Player({
      canvas: canvas,
      width: config.width || canvas.clientWidth,
      height: config.height || canvas.clientHeight,
  
      // H265专用配置
      decoder: config.decoder || '/players/h265web/h265web.wasm',
      autoPlay: config.autoPlay,
      debug: config.debug,
  
      // 事件回调
      onReady: () => {
        console.log('H265播放器准备就绪')
        playerStatus.value = 'idle'
      },
      onPlay: handlePlay,
      onPause: handlePause,
      onError: handleError,
      onLoadStart: () => {
        loading.value = true
        playerStatus.value = 'loading'
      },
      onLoadedData: () => {
        loading.value = false
        handleLoad()
      }
    })
  }

  // 开始播放
  const startPlay = async (url: string) => {
    if (!playerInstance.value) {
      throw new Error('播放器未初始化')
    }
  
    try {
      loading.value = true
      error.value = ''
      playerStatus.value = 'loading'
  
      if (currentPlayerType.value === 'jessibuca') {
        playerInstance.value.play(url)
      } else if (currentPlayerType.value === 'h265web') {
        await playerInstance.value.load(url)
        if (defaultConfig.autoPlay) {
          await playerInstance.value.play()
        }
      }
  
    } catch (err) {
      error.value = err.message || '播放失败'
      playerStatus.value = 'error'
      loading.value = false
      throw err
    }
  }

  // 停止播放
  const stopPlay = async () => {
    if (!playerInstance.value) return
  
    try {
      if (currentPlayerType.value === 'jessibuca') {
        playerInstance.value.destroy()
      } else if (currentPlayerType.value === 'h265web') {
        playerInstance.value.pause()
        playerInstance.value.stop()
      }
  
      isPlaying.value = false
      playerStatus.value = 'idle'
  
    } catch (err) {
      console.error('停止播放失败:', err)
    }
  }

  // 切换播放/暂停
  const togglePlay = async () => {
    if (!playerInstance.value) return
  
    try {
      if (isPlaying.value) {
        if (currentPlayerType.value === 'jessibuca') {
          playerInstance.value.pause()
        } else if (currentPlayerType.value === 'h265web') {
          playerInstance.value.pause()
        }
      } else {
        if (currentPlayerType.value === 'jessibuca') {
          playerInstance.value.play()
        } else if (currentPlayerType.value === 'h265web') {
          playerInstance.value.play()
        }
      }
    } catch (err) {
      error.value = err.message || '播放控制失败'
    }
  }

  // 切换录像
  const toggleRecord = async () => {
    if (!playerInstance.value) return
  
    try {
      if (currentPlayerType.value === 'jessibuca') {
        if (isRecording.value) {
          playerInstance.value.stopRecord()
        } else {
          playerInstance.value.startRecord()
        }
      } else {
        message.warning('H265播放器暂不支持本地录像')
      }
    } catch (err) {
      error.value = err.message || '录像控制失败'
    }
  }

  // 切换全屏
  const toggleFullscreen = async () => {
    try {
      if (isFullscreen.value) {
        if (document.exitFullscreen) {
          await document.exitFullscreen()
        }
      } else {
        const element = playerRef.value || canvasRef.value
        if (element && element.requestFullscreen) {
          await element.requestFullscreen()
        }
      }
    } catch (err) {
      console.error('全屏切换失败:', err)
    }
  }

  // 截图
  const screenshot = (): Promise<string> => {
    return new Promise((resolve, reject) => {
      if (!playerInstance.value) {
        reject(new Error('播放器未初始化'))
        return
      }
  
      try {
        if (currentPlayerType.value === 'jessibuca') {
          playerInstance.value.screenshot('image/jpeg', '', 'base64', (base64: string) => {
            resolve(base64)
          })
        } else if (currentPlayerType.value === 'h265web') {
          const canvas = canvasRef.value
          if (canvas) {
            resolve(canvas.toDataURL('image/jpeg'))
          } else {
            reject(new Error('无法获取画布'))
          }
        }
      } catch (err) {
        reject(err)
      }
    })
  }

  // 销毁播放器
  const destroy = () => {
    try {
      if (playerInstance.value) {
        if (currentPlayerType.value === 'jessibuca') {
          playerInstance.value.destroy()
        } else if (currentPlayerType.value === 'h265web') {
          playerInstance.value.destroy()
        }
        playerInstance.value = null
      }
  
      // 重置状态
      isPlaying.value = false
      isRecording.value = false
      isFullscreen.value = false
      loading.value = false
      error.value = ''
      playerStatus.value = 'idle'
      streamInfo.value = null
  
    } catch (err) {
      console.error('销毁播放器失败:', err)
    }
  }

  // 事件处理函数
  const handlePlay = () => {
    isPlaying.value = true
    playerStatus.value = 'playing'
    loading.value = false
    console.log('播放开始')
  }

  const handlePause = () => {
    isPlaying.value = false
    playerStatus.value = 'paused'
    console.log('播放暂停')
  }

  const handleLoad = () => {
    loading.value = false
    console.log('流加载完成')
  }

  const handleError = (error: any) => {
    console.error('播放器错误:', error)
    loading.value = false
    playerStatus.value = 'error'
    isPlaying.value = false
    error.value = error.message || '播放出现错误'
  }

  const handleTimeUpdate = (time: number) => {
    // 处理时间更新
  }

  const handleMute = (muted: boolean) => {
    console.log('静音状态:', muted)
  }

  const handleLog = (log: any) => {
    if (defaultConfig.debug) {
      console.log('播放器日志:', log)
    }
  }

  const handleKBps = (kbps: number) => {
    // 处理码率信息
  }

  const handleRecord = (recording: boolean) => {
    isRecording.value = recording
    console.log('录像状态:', recording)
  }

  const handleBuffer = (buffer: number) => {
    // 处理缓冲信息
  }

  const handleResolutionChange = (width: number, height: number) => {
    streamInfo.value = {
      ...streamInfo.value,
      width,
      height,
      resolution: `${width}x${height}`
    }
    console.log('分辨率变化:', width, height)
  }

  // 监听全屏变化
  const handleFullscreenChange = () => {
    isFullscreen.value = !!document.fullscreenElement
  }

  // 设置全屏监听
  document.addEventListener('fullscreenchange', handleFullscreenChange)

  // 组件卸载时清理
  onUnmounted(() => {
    destroy()
    document.removeEventListener('fullscreenchange', handleFullscreenChange)
  })

  return {
    // 引用
    playerRef,
    canvasRef,
    playerInstance,
  
    // 状态
    currentPlayerType,
    playerStatus,
    isPlaying,
    isRecording,
    isFullscreen,
    loading,
    error,
    streamInfo,
  
    // ID
    playerId,
    canvasId,
  
    // 计算属性
    canPlay,
    canPause,
  
    // 方法
    initPlayer,
    startPlay,
    stopPlay,
    togglePlay,
    toggleRecord,
    toggleFullscreen,
    screenshot,
    destroy
  }
}
```

### 7.2 云台控制组件

#### 7.2.1 PTZ控制组件

```
<!-- src/components/business/PTZControl/index.vue -->
<template>
  <div class="ptz-control-panel" :class="{ 'panel-expanded': expanded }">
    <!-- 控制面板头部 -->
    <div class="panel-header" @click="toggleExpand">
      <h4>云台控制</h4>
      <a-button type="text" size="small">
        <UpOutlined v-if="expanded" />
        <DownOutlined v-else />
      </a-button>
    </div>
  
    <!-- 控制面板内容 -->
    <div v-show="expanded" class="panel-content">
      <!-- 方向控制 -->
      <div class="direction-control">
        <div class="control-grid">
          <!-- 第一行 -->
          <div class="grid-row">
            <a-button 
              @mousedown="startMove('LEFT_UP')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn diagonal"
            >
              <div class="arrow arrow-left-up"></div>
            </a-button>
            <a-button 
              @mousedown="startMove('UP')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn"
            >
              <UpOutlined />
            </a-button>
            <a-button 
              @mousedown="startMove('RIGHT_UP')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn diagonal"
            >
              <div class="arrow arrow-right-up"></div>
            </a-button>
          </div>
    
          <!-- 第二行 -->
          <div class="grid-row">
            <a-button 
              @mousedown="startMove('LEFT')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn"
            >
              <LeftOutlined />
            </a-button>
            <a-button 
              @click="stopMove"
              class="direction-btn center-btn"
              :class="{ 'active': isMoving }"
            >
              <BorderOutlined />
            </a-button>
            <a-button 
              @mousedown="startMove('RIGHT')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn"
            >
              <RightOutlined />
            </a-button>
          </div>
    
          <!-- 第三行 -->
          <div class="grid-row">
            <a-button 
              @mousedown="startMove('LEFT_DOWN')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn diagonal"
            >
              <div class="arrow arrow-left-down"></div>
            </a-button>
            <a-button 
              @mousedown="startMove('DOWN')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn"
            >
              <DownOutlined />
            </a-button>
            <a-button 
              @mousedown="startMove('RIGHT_DOWN')"
              @mouseup="stopMove"
              @mouseleave="stopMove"
              class="direction-btn diagonal"
            >
              <div class="arrow arrow-right-down"></div>
            </a-button>
          </div>
        </div>
  
        <!-- 速度控制 -->
        <div class="speed-control">
          <label>移动速度</label>
          <a-slider 
            v-model:value="moveSpeed" 
            :min="1" 
            :max="7" 
            :step="1"
            :marks="speedMarks"
          />
        </div>
      </div>
  
      <!-- 缩放控制 -->
      <div class="zoom-control">
        <div class="zoom-buttons">
          <a-button 
            @mousedown="startZoom('IN')"
            @mouseup="stopZoom"
            @mouseleave="stopZoom"
            class="zoom-btn"
          >
            <PlusOutlined />
            <span>放大</span>
          </a-button>
          <a-button 
            @mousedown="startZoom('OUT')"
            @mouseup="stopZoom"
            @mouseleave="stopZoom"
            class="zoom-btn"
          >
            <MinusOutlined />
            <span>缩小</span>
          </a-button>
        </div>
  
        <div class="zoom-speed">
          <label>缩放速度</label>
          <a-slider 
            v-model:value="zoomSpeed" 
            :min="1" 
            :max="7" 
            :step="1"
          />
        </div>
      </div>
  
      <!-- 焦距控制 -->
      <div class="focus-control">
        <div class="focus-buttons">
          <a-button 
            @mousedown="startFocus('NEAR')"
            @mouseup="stopFocus"
            @mouseleave="stopFocus"
            class="focus-btn"
          >
            <span>近焦</span>
          </a-button>
          <a-button 
            @mousedown="startFocus('FAR')"
            @mouseup="stopFocus"
            @mouseleave="stopFocus"
            class="focus-btn"
          >
            <span>远焦</span>
          </a-button>
        </div>
  
        <a-button @click="autoFocus" class="auto-focus-btn">
          <AimOutlined />
          自动对焦
        </a-button>
      </div>
  
      <!-- 光圈控制 -->
      <div class="iris-control">
        <div class="iris-buttons">
          <a-button 
            @mousedown="startIris('OPEN')"
            @mouseup="stopIris"
            @mouseleave="stopIris"
            class="iris-btn"
          >
            <span>光圈+</span>
          </a-button>
          <a-button 
            @mousedown="startIris('CLOSE')"
            @mouseup="stopIris"
            @mouseleave="stopIris"
            class="iris-btn"
          >
            <span>光圈-</span>
          </a-button>
        </div>
      </div>
  
      <!-- 预置位控制 -->
      <div class="preset-control">
        <div class="preset-header">
          <h5>预置位</h5>
          <a-button size="small" @click="loadPresets">
            <ReloadOutlined />
          </a-button>
        </div>
  
        <div class="preset-list">
          <div 
            v-for="preset in presets" 
            :key="preset.id"
            class="preset-item"
          >
            <span class="preset-name">{{ preset.name }}</span>
            <div class="preset-actions">
              <a-button size="small" @click="callPreset(preset.id)">
                调用
              </a-button>
              <a-button size="small" @click="setPreset(preset.id)">
                设置
              </a-button>
              <a-popconfirm
                title="确定要删除这个预置位吗？"
                @confirm="deletePreset(preset.id)"
              >
                <a-button size="small" danger>
                  删除
                </a-button>
              </a-popconfirm>
            </div>
          </div>
        </div>
  
        <div class="preset-add">
          <a-input-group compact>
            <a-input 
              v-model:value="newPresetName" 
              placeholder="预置位名称"
              style="width: 60%"
            />
            <a-button @click="addPreset" style="width: 40%">
              <PlusOutlined />
              添加
            </a-button>
          </a-input-group>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { message } from 'ant-design-vue'
import { streamAPI } from '@/api/modules/stream'

interface Props {
  deviceId: string
  channelId: string
  disabled?: boolean
}

interface PTZPreset {
  id: number
  name: string
}

const props = defineProps<Props>()
const emit = defineEmits<{
  'command': [command: any]
}>()

// 面板状态
const expanded = ref(true)

// 控制状态
const isMoving = ref(false)
const isZooming = ref(false)
const isFocusing = ref(false)
const isIrisAdjusting = ref(false)

// 控制参数
const moveSpeed = ref(4)
const zoomSpeed = ref(4)
const currentCommand = ref('')

// 预置位
const presets = ref<PTZPreset[]>([])
const newPresetName = ref('')

// 定时器
const commandTimer = ref<NodeJS.Timeout | null>(null)

// 速度标记
const speedMarks = {
  1: '1',
  4: '4', 
  7: '7'
}

// 切换面板展开状态
const toggleExpand = () => {
  expanded.value = !expanded.value
}

// 开始移动
const startMove = (direction: string) => {
  if (props.disabled) return
  
  isMoving.value = true
  currentCommand.value = direction
  
  sendPTZCommand({
    command: direction,
    parameter1: moveSpeed.value,
    parameter2: 0,
    parameter3: 0
  })
  
  // 持续发送命令
  commandTimer.value = setInterval(() => {
    sendPTZCommand({
      command: direction,
      parameter1: moveSpeed.value,
      parameter2: 0,
      parameter3: 0
    })
  }, 100)
}

// 停止移动
const stopMove = () => {
  if (commandTimer.value) {
    clearInterval(commandTimer.value)
    commandTimer.value = null
  }
  
  if (isMoving.value) {
    sendPTZCommand({
      command: 'STOP',
      parameter1: 0,
      parameter2: 0,
      parameter3: 0
    })
  }
  
  isMoving.value = false
  currentCommand.value = ''
}

// 开始缩放
const startZoom = (direction: 'IN' | 'OUT') => {
  if (props.disabled) return
  
  isZooming.value = true
  
  const command = direction === 'IN' ? 'ZOOM_IN' : 'ZOOM_OUT'
  sendPTZCommand({
    command,
    parameter1: zoomSpeed.value,
    parameter2: 0,
    parameter3: 0
  })
  
  commandTimer.value = setInterval(() => {
    sendPTZCommand({
      command,
      parameter1: zoomSpeed.value,
      parameter2: 0,
      parameter3: 0
    })
  }, 100)
}

// 停止缩放
const stopZoom = () => {
  if (commandTimer.value) {
    clearInterval(commandTimer.value)
    commandTimer.value = null
  }
  
  if (isZooming.value) {
    sendPTZCommand({
      command: 'ZOOM_STOP',
      parameter1: 0,
      parameter2: 0,
      parameter3: 0
    })
  }
  
  isZooming.value = false
}

// 开始调焦
const startFocus = (direction: 'NEAR' | 'FAR') => {
  if (props.disabled) return
  
  isFocusing.value = true
  
  const command = direction === 'NEAR' ? 'FOCUS_NEAR' : 'FOCUS_FAR'
  sendPTZCommand({
    command,
    parameter1: 4,
    parameter2: 0,
    parameter3: 0
  })
}

// 停止调焦
const stopFocus = () => {
  if (isFocusing.value) {
    sendPTZCommand({
      command: 'FOCUS_STOP',
      parameter1: 0,
      parameter2: 0,
      parameter3: 0
    })
  }
  
  isFocusing.value = false
}

// 自动对焦
const autoFocus = () => {
  sendPTZCommand({
    command: 'AUTO_FOCUS',
    parameter1: 0,
    parameter2: 0,
    parameter3: 0
  })
  message.success('自动对焦命令已发送')
}

// 开始调光圈
const startIris = (direction: 'OPEN' | 'CLOSE') => {
  if (props.disabled) return
  
  isIrisAdjusting.value = true
  
  const command = direction === 'OPEN' ? 'IRIS_OPEN' : 'IRIS_CLOSE'
  sendPTZCommand({
    command,
    parameter1: 4,
    parameter2: 0,
    parameter3: 0
  })
}

// 停止调光圈
const stopIris = () => {
  if (isIrisAdjusting.value) {
    sendPTZCommand({
      command: 'IRIS_STOP',
      parameter1: 0,
      parameter2: 0,
      parameter3: 0
    })
  }
  
  isIrisAdjusting.value = false
}

// 调用预置位
const callPreset = async (presetId: number) => {
  try {
    await sendPTZCommand({
      command: 'PRESET_CALL',
      parameter1: presetId,
      parameter2: 0,
      parameter3: 0
    })
    message.success(`预置位 ${presetId} 调用成功`)
  } catch (error) {
    message.error('预置位调用失败')
  }
}

// 设置预置位
const setPreset = async (presetId: number) => {
  try {
    await sendPTZCommand({
      command: 'PRESET_SET',
      parameter1: presetId,
      parameter2: 0,
      parameter3: 0
    })
    message.success(`预置位 ${presetId} 设置成功`)
  } catch (error) {
    message.error('预置位设置失败')
  }
}

// 删除预置位
const deletePreset = async (presetId: number) => {
  try {
    await sendPTZCommand({
      command: 'PRESET_DELETE',
      parameter1: presetId,
      parameter2: 0,
      parameter3: 0
    })
  
    // 从列表中移除
    presets.value = presets.value.filter(p => p.id !== presetId)
    message.success('预置位删除成功')
  } catch (error) {
    message.error('预置位删除失败')
  }
}

// 添加预置位
const addPreset = async () => {
  if (!newPresetName.value.trim()) {
    message.warning('请输入预置位名称')
    return
  }
  
  try {
    // 找到下一个可用ID
    const nextId = Math.max(...presets.value.map(p => p.id), 0) + 1
  
    await setPreset(nextId)
  
    // 添加到列表
    presets.value.push({
      id: nextId,
      name: newPresetName.value.trim()
    })
  
    newPresetName.value = ''
    message.success('预置位添加成功')
  } catch (error) {
    message.error('预置位添加失败')
  }
}

// 加载预置位列表
const loadPresets = async () => {
  try {
    const response = await streamAPI.getPTZPresets(props.deviceId, props.channelId)
    presets.value = response.data
  } catch (error) {
    console.error('加载预置位失败:', error)
  }
}

// 发送PTZ命令
const sendPTZCommand = async (command: any) => {
  try {
    await streamAPI.sendPTZCommand({
      deviceId: props.deviceId,
      channelId: props.channelId,
      ...command
    })
  
    // 触发事件
    emit('command', command)
  
  } catch (error) {
    console.error('PTZ命令发送失败:', error)
    throw error
  }
}

// 键盘控制
const handleKeyDown = (event: KeyboardEvent) => {
  if (props.disabled) return
  
  const { key } = event
  
  // 防止重复触发
  if (isMoving.value) return
  
  switch (key) {
    case 'ArrowUp':
      event.preventDefault()
      startMove('UP')
      break
    case 'ArrowDown':
      event.preventDefault()
      startMove('DOWN')
      break
    case 'ArrowLeft':
      event.preventDefault()
      startMove('LEFT')
      break
    case 'ArrowRight':
      event.preventDefault()
      startMove('RIGHT')
      break
    case '+':
      event.preventDefault()
      startZoom('IN')
      break
    case '-':
      event.preventDefault()
      startZoom('OUT')
      break
  }
}

const handleKeyUp = (event: KeyboardEvent) => {
  const { key } = event
  
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
    stopMove()
  } else if (['+', '-'].includes(key)) {
    stopZoom()
  }
}

// 生命周期
onMounted(() => {
  loadPresets()
  
  // 添加键盘监听
  window.addEventListener('keydown', handleKeyDown)
  window.addEventListener('keyup', handleKeyUp)
})

onUnmounted(() => {
  // 清理定时器
  if (commandTimer.value) {
    clearInterval(commandTimer.value)
  }
  
  // 移除键盘监听
  window.removeEventListener('keydown', handleKeyDown)
  window.removeEventListener('keyup', handleKeyUp)
})
</script>

<style lang="scss" scoped>
.ptz-control-panel {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  transition: all 0.3s;

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    background: #f5f5f5;
    border-bottom: 1px solid #e8e8e8;
    cursor: pointer;
    user-select: none;

    h4 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
    }
  }

  .panel-content {
    padding: 16px;
  }

  .direction-control {
    margin-bottom: 24px;

    .control-grid {
      .grid-row {
        display: flex;
        justify-content: center;
        gap: 4px;
        margin-bottom: 4px;

        .direction-btn {
          width: 40px;
          height: 40px;
          padding: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 4px;

          &.center-btn {
            background: #f0f0f0;
      
            &.active {
              background: #ff4d4f;
              color: white;
            }
          }

          &.diagonal {
            .arrow {
              width: 0;
              height: 0;
              border: 6px solid transparent;

              &.arrow-left-up {
                border-right-color: currentColor;
                border-bottom-color: currentColor;
                transform: rotate(-45deg);
              }

              &.arrow-right-up {
                border-left-color: currentColor;
                border-bottom-color: currentColor;
                transform: rotate(45deg);
              }

              &.arrow-left-down {
                border-right-color: currentColor;
                border-top-color: currentColor;
                transform: rotate(45deg);
              }

              &.arrow-right-down {
                border-left-color: currentColor;
                border-top-color: currentColor;
                transform: rotate(-45deg);
              }
            }
          }
        }
      }
    }

    .speed-control {
      margin-top: 16px;

      label {
        display: block;
        margin-bottom: 8px;
        font-size: 12px;
        color: #666;
      }
    }
  }

  .zoom-control,
  .focus-control,
  .iris-control {
    margin-bottom: 20px;

    .zoom-buttons,
    .focus-buttons,
    .iris-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;

      .zoom-btn,
      .focus-btn,
      .iris-btn {
        flex: 1;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
      }
    }

    .auto-focus-btn {
      width: 100%;
      height: 36px;
    }

    .zoom-speed {
      label {
        display: block;
        margin-bottom: 8px;
        font-size: 12px;
        color: #666;
      }
    }
  }

  .preset-control {
    .preset-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;

      h5 {
        margin: 0;
        font-size: 13px;
        font-weight: 600;
      }
    }

    .preset-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 12px;

      .preset-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 1px solid #f0f0f0;

        &:last-child {
          border-bottom: none;
        }

        .preset-name {
          font-size: 12px;
          flex: 1;
        }

        .preset-actions {
          display: flex;
          gap: 4px;

          .ant-btn {
            height: 24px;
            padding: 0 8px;
            font-size: 11px;
          }
        }
      }
    }

    .preset-add {
      margin-top: 12px;
    }
  }
}

.panel-expanded {
  .panel-content {
    animation: slideDown 0.3s ease-out;
  }
}

@keyframes slideDown {
  from {
    max-height: 0;
    opacity: 0;
  }
  to {
    max-height: 1000px;
    opacity: 1;
  }
}
</style>
```

## 8. 部署配置与分工方案

### 8.1 开发环境配置

#### 8.1.1 Vite配置

```
// vite.config.ts
import { defineConfig, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'
import { viteMockPlugin } from 'vite-plugin-mock'

export default defineConfig(({ command, mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  const isBuild = command === 'build'

  return {
    plugins: [
      vue(),
  
      // SVG图标插件
      createSvgIconsPlugin({
        iconDirs: [resolve(process.cwd(), 'src/assets/icons')],
        symbolId: 'icon-[dir]-[name]',
      }),
  
      // Mock插件
      viteMockPlugin({
        mockPath: 'mock',
        localEnabled: !isBuild,
        prodEnabled: false,
        injectCode: `
          import { setupProdMockServer } from './mockProdServer';
          setupProdMockServer();
        `,
      }),
    ],

    // 路径别名
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
        '@components': resolve(__dirname, 'src/components'),
        '@views': resolve(__dirname, 'src/views'),
        '@assets': resolve(__dirname, 'src/assets'),
        '@utils': resolve(__dirname, 'src/utils'),
        '@api': resolve(__dirname, 'src/api'),
        '@stores': resolve(__dirname, 'src/stores'),
        '@types': resolve(__dirname, 'src/types'),
      },
    },

    // CSS预处理器
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: `
            @import "@/assets/styles/variables.scss";
            @import "@/assets/styles/mixins.scss";
          `,
        },
      },
    },

    // 开发服务器配置
    server: {
      host: '0.0.0.0',
      port: 3000,
      open: true,
      cors: true,
      proxy: {
        '/api': {
          target: env.VITE_API_BASE_URL || 'http://localhost:8000',
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/api/, ''),
        },
        '/ws': {
          target: env.VITE_WS_BASE_URL || 'ws://localhost:8000',
          ws: true,
          changeOrigin: true,
        },
      },
    },

    // 构建配置
    build: {
      target: 'es2015',
      outDir: 'dist',
      assetsDir: 'assets',
      sourcemap: false,
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: true,
          drop_debugger: true,
        },
      },
  
      // 分包策略
      rollupOptions: {
        output: {
          chunkFileNames: 'assets/js/[name]-[hash].js',
          entryFileNames: 'assets/js/[name]-[hash].js',
          assetFileNames: 'assets/[ext]/[name]-[hash].[ext]',
    
          manualChunks: {
            vue: ['vue', 'vue-router', 'pinia'],
            antd: ['ant-design-vue', '@ant-design/icons-vue'],
            vendor: ['axios', 'dayjs', 'lodash-es'],
            players: ['jessibuca'],
          },
        },
      },
  
      // 分包大小警告阈值
      chunkSizeWarningLimit: 1500,
    },

    // 预构建优化
    optimizeDeps: {
      include: [
        'vue',
        'vue-router',
        'pinia',
        'ant-design-vue',
        '@ant-design/icons-vue',
        'axios',
        'dayjs',
        'lodash-es',
      ],
    },

    // 环境变量前缀
    envPrefix: 'VITE_',
  }
})
```

#### 8.1.2 环境变量配置

bash

```
# .env.development - 开发环境
VITE_APP_TITLE=GB28181视频平台 - 开发环境
VITE_APP_ENV=development
VITE_API_BASE_URL=http://localhost:8000
VITE_WS_BASE_URL=ws://localhost:8000
VITE_UPLOAD_URL=http://localhost:8000/upload
VITE_APP_VERSION=1.0.0-dev

# 播放器配置
VITE_JESSIBUCA_DECODER_PATH=/players/jessibuca/decoder.wasm
VITE_H265WEB_DECODER_PATH=/players/h265web/h265web.wasm

# 开发配置
VITE_MOCK_ENABLED=true
VITE_DEBUG_ENABLED=true
VITE_DEVTOOLS_ENABLED=true
```

```
# .env.production - 生产环境
VITE_APP_TITLE=GB28181视频平台
VITE_APP_ENV=production
VITE_API_BASE_URL=
VITE_WS_BASE_URL=
VITE_UPLOAD_URL=/upload
VITE_APP_VERSION=1.0.0

# 播放器配置
VITE_JESSIBUCA_DECODER_PATH=/players/jessibuca/decoder.wasm
VITE_H265WEB_DECODER_PATH=/players/h265web/h265web.wasm

# 生产配置
VITE_MOCK_ENABLED=false
VITE_DEBUG_ENABLED=false
VITE_DEVTOOLS_ENABLED=false
```

### 8.2 Docker部署配置

#### 8.2.1 Dockerfile

```
# docker/Dockerfile
# 构建阶段
FROM node:18-alpine AS builder

# 设置工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./
COPY pnpm-lock.yaml ./

# 安装pnpm
RUN npm install -g pnpm

# 安装依赖
RUN pnpm install --frozen-lockfile

# 复制源代码
COPY . .

# 构建应用
RUN pnpm build

# 生产阶段
FROM nginx:1.25-alpine

# 安装必要工具
RUN apk add --no-cache \
    curl \
    tzdata \
    && cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
    && echo "Asia/Shanghai" > /etc/timezone

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制Nginx配置
COPY docker/nginx.conf /etc/nginx/nginx.conf
COPY docker/default.conf /etc/nginx/conf.d/default.conf

# 复制启动脚本
COPY docker/docker-entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# 创建日志目录
RUN mkdir -p /var/log/nginx

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:80/ || exit 1

# 暴露端口
EXPOSE 80

# 启动命令
ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]
```

#### 8.2.2 Nginx配置

```
# docker/nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log notice;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    # 基础设置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # 包含站点配置
    include /etc/nginx/conf.d/*.conf;
}
```

```
nginx# docker/default.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html index.htm;

    # 错误页面
    error_page 404 /index.html;
    error_page 500 502 503 504 /50x.html;

    # 主应用路由
    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Vary Accept-Encoding;
        access_log off;
    }

    # 播放器资源
    location /players/ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Access-Control-Allow-Origin "*";
        add_header Access-Control-Allow-Methods "GET, OPTIONS";
        add_header Access-Control-Allow-Headers "Range";
    }

    # API代理
    location /api/ {
        proxy_pass http://gb28181-core:8000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # WebSocket代理
    location /ws {
        proxy_pass http://gb28181-core:8000/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 86400s;
    }

    # 健康检查
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # 安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
}
```

#### 8.2.3 Docker启动脚本

bash

```
#!/bin/sh
# docker/docker-entrypoint.sh

set -e

# 环境变量替换函数
envsubst_file() {
    local file="$1"
    local temp_file="${file}.tmp"
  
    envsubst < "$file" > "$temp_file"
    mv "$temp_file" "$file"
}

# 替换配置文件中的环境变量
if [ -f "/usr/share/nginx/html/config/app.config.js" ]; then
    echo "正在更新应用配置..."
    envsubst_file "/usr/share/nginx/html/config/app.config.js"
fi

# 创建运行时配置
cat > /usr/share/nginx/html/config/runtime.config.js << EOF
window.APP_CONFIG = {
  apiBaseUrl: '${API_BASE_URL:-/api}',
  wsBaseUrl: '${WS_BASE_URL:-/ws}',
  uploadUrl: '${UPLOAD_URL:-/upload}',
  title: '${APP_TITLE:-GB28181视频平台}',
  version: '${APP_VERSION:-1.0.0}',
  env: '${APP_ENV:-production}',
  
  // 播放器配置
  jessibucaDecoder: '${JESSIBUCA_DECODER_PATH:-/players/jessibuca/decoder.wasm}',
  h265webDecoder: '${H265WEB_DECODER_PATH:-/players/h265web/h265web.wasm}',
  
  // 功能开关
  debugEnabled: ${DEBUG_ENABLED:-false},
  mockEnabled: false
};
EOF

echo "配置文件已生成"

# 执行传入的命令
exec "$@"
```

#### 8.2.4 Docker Compose集成

yaml

```
# docker-compose.yml (前端部分)
version: '3.8'

services:
  # 前端应用
  frontend:
    build:
      context: ./web-frontend
      dockerfile: docker/Dockerfile
    container_name: gb28181-frontend
    environment:
      - API_BASE_URL=/api
      - WS_BASE_URL=/ws
      - UPLOAD_URL=/upload
      - APP_TITLE=GB28181视频平台
      - APP_VERSION=1.0.0
      - APP_ENV=production
      - JESSIBUCA_DECODER_PATH=/players/jessibuca/decoder.wasm
      - H265WEB_DECODER_PATH=/players/h265web/h265web.wasm
      - DEBUG_ENABLED=false
    ports:
      - "80:80"
    volumes:
      - ./web-frontend/public/players:/usr/share/nginx/html/players:ro
      - ./logs/nginx:/var/log/nginx
    depends_on:
      core-service:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    networks:
      - gb28181-network

networks:
  gb28181-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

### 8.3 构建与部署流程

#### 8.3.1 自动化构建脚本

```
#!/bin/bash
# scripts/build.sh - 构建脚本

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 打印带颜色的日志
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查环境
check_environment() {
    log_info "检查构建环境..."
  
    # 检查Node.js版本
    if ! command -v node &> /dev/null; then
        log_error "Node.js未安装"
        exit 1
    fi
  
    NODE_VERSION=$(node --version | cut -d'v' -f2 | cut -d'.' -f1)
    if [ "$NODE_VERSION" -lt 16 ]; then
        log_error "Node.js版本过低，需要v16+，当前版本: $(node --version)"
        exit 1
    fi
  
    # 检查pnpm版本
    if ! command -v pnpm &> /dev/null; then
        log_warn "pnpm未安装，正在安装..."
        npm install -g pnpm
    fi
  
    log_info "环境检查通过"
}

# 安装依赖
install_dependencies() {
    log_info "安装项目依赖..."
  
    if [ ! -f "pnpm-lock.yaml" ]; then
        log_warn "pnpm-lock.yaml不存在，执行完整安装"
        pnpm install
    else
        pnpm install --frozen-lockfile
    fi
  
    log_info "依赖安装完成"
}

# 代码检查
code_check() {
    log_info "执行代码检查..."
  
    # TypeScript类型检查
    log_info "TypeScript类型检查..."
    pnpm run type-check
  
    # ESLint检查
    log_info "ESLint代码检查..."
    pnpm run lint
  
    # 单元测试
    if [ -d "src/__tests__" ]; then
        log_info "运行单元测试..."
        pnpm run test:unit
    fi
  
    log_info "代码检查完成"
}

# 构建应用
build_app() {
    local env=${1:-production}
  
    log_info "构建应用 (环境: $env)..."
  
    # 清理旧的构建产物
    rm -rf dist
  
    # 设置构建环境
    export NODE_ENV=$env
  
    # 执行构建
    pnpm run build
  
    # 检查构建产物
    if [ ! -d "dist" ]; then
        log_error "构建失败，dist目录不存在"
        exit 1
    fi
  
    log_info "应用构建完成"
}

# 构建分析
build_analysis() {
    log_info "执行构建分析..."
  
    # 包大小分析
    pnpm run build:analyze
  
    # 生成构建报告
    cat > dist/build-info.json << EOF
{
  "buildTime": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "version": "$(node -p "require('./package.json').version")",
  "commit": "$(git rev-parse HEAD 2>/dev/null || echo 'unknown')",
  "branch": "$(git branch --show-current 2>/dev/null || echo 'unknown')",
  "nodeVersion": "$(node --version)",
  "environment": "${NODE_ENV:-production}"
}
EOF
  
    log_info "构建分析完成"
}

# 主函数
main() {
    local env=${1:-production}
    local skip_checks=${2:-false}
  
    log_info "开始构建前端应用..."
    log_info "构建环境: $env"
  
    # 检查环境
    check_environment
  
    # 安装依赖
    install_dependencies
  
    # 代码检查（可跳过）
    if [ "$skip_checks" != "true" ]; then
        code_check
    fi
  
    # 构建应用
    build_app "$env"
  
    # 构建分析
    build_analysis
  
    log_info "前端应用构建完成！"
    log_info "构建产物位置: $(pwd)/dist"
}

# 显示帮助信息
show_help() {
    echo "用法: $0 [环境] [选项]"
    echo ""
    echo "环境:"
    echo "  development  开发环境构建"
    echo "  production   生产环境构建 (默认)"
    echo ""
    echo "选项:"
    echo "  --skip-checks  跳过代码检查"
    echo "  --help         显示帮助信息"
    echo ""
    echo "示例:"
    echo "  $0                      # 生产环境构建"
    echo "  $0 development          # 开发环境构建"
    echo "  $0 production --skip-checks  # 生产环境构建，跳过检查"
}

# 处理命令行参数
case "$1" in
    --help|-h)
        show_help
        exit 0
        ;;
    development|production)
        main "$1" "$2"
        ;;
    "")
        main "production" "$1"
        ;;
    *)
        log_error "无效的环境: $1"
        show_help
        exit 1
        ;;
esac
```

#### 8.3.2 部署脚本

bash

```
#!/bin/bash
# scripts/deploy.sh - 部署脚本

set -e

# 配置
DOCKER_REGISTRY="${DOCKER_REGISTRY:-}"
IMAGE_NAME="${IMAGE_NAME:-gb28181-frontend}"
IMAGE_TAG="${IMAGE_TAG:-latest}"
DEPLOY_ENV="${DEPLOY_ENV:-production}"

# 日志函数
log_info() {
    echo -e "\033[0;32m[INFO]\033[0m $1"
}

log_warn() {
    echo -e "\033[1;33m[WARN]\033[0m $1"
}

log_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $1"
}

# 构建Docker镜像
build_image() {
    log_info "构建Docker镜像..."
  
    local full_image_name="$IMAGE_NAME:$IMAGE_TAG"
    if [ -n "$DOCKER_REGISTRY" ]; then
        full_image_name="$DOCKER_REGISTRY/$full_image_name"
    fi
  
    docker build \
        -f docker/Dockerfile \
        -t "$full_image_name" \
        --build-arg BUILD_ENV="$DEPLOY_ENV" \
        .
  
    log_info "Docker镜像构建完成: $full_image_name"
}

# 推送镜像
push_image() {
    if [ -z "$DOCKER_REGISTRY" ]; then
        log_warn "未配置Docker registry，跳过镜像推送"
        return
    fi
  
    log_info "推送Docker镜像到registry..."
  
    local full_image_name="$DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
    docker push "$full_image_name"
  
    log_info "镜像推送完成"
}

# 部署到测试环境
deploy_staging() {
    log_info "部署到测试环境..."
  
    # 更新docker-compose文件
    export IMAGE_TAG
    envsubst < docker-compose.staging.yml.template > docker-compose.staging.yml
  
    # 启动服务
    docker-compose -f docker-compose.staging.yml down
    docker-compose -f docker-compose.staging.yml up -d
  
    # 等待服务启动
    sleep 30
  
    # 健康检查
    if curl -f http://localhost:8080/health > /dev/null 2>&1; then
        log_info "测试环境部署成功"
    else
        log_error "测试环境部署失败"
        exit 1
    fi
}

# 部署到生产环境
deploy_production() {
    log_info "部署到生产环境..."
  
    # 安全确认
    read -p "确定要部署到生产环境吗? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "部署已取消"
        exit 0
    fi
  
    # 备份当前版本
    log_info "备份当前版本..."
    docker tag "$IMAGE_NAME:latest" "$IMAGE_NAME:backup-$(date +%Y%m%d-%H%M%S)" || true
  
    # 更新服务
    export IMAGE_TAG
    envsubst < docker-compose.production.yml.template > docker-compose.production.yml
  
    # 滚动更新
    docker-compose -f docker-compose.production.yml up -d --no-deps frontend
  
    # 等待服务启动
    sleep 60
  
    # 健康检查
    local retry_count=0
    local max_retries=10
  
    while [ $retry_count -lt $max_retries ]; do
        if curl -f http://localhost/health > /dev/null 2>&1; then
            log_info "生产环境部署成功"
            return 0
        fi
  
        retry_count=$((retry_count + 1))
        log_warn "健康检查失败，重试 $retry_count/$max_retries"
        sleep 10
    done
  
    log_error "生产环境部署失败"
  
    # 回滚
    log_info "执行回滚..."
    docker-compose -f docker-compose.production.yml down
    docker tag "$IMAGE_NAME:backup-$(date +%Y%m%d)" "$IMAGE_NAME:latest" || true
    docker-compose -f docker-compose.production.yml up -d --no-deps frontend
  
    exit 1
}

# 清理旧镜像
cleanup_images() {
    log_info "清理旧的Docker镜像..."
  
    # 删除未使用的镜像
    docker image prune -f
  
    # 保留最近的5个版本
    docker images "$IMAGE_NAME" --format "table {{.Tag}}\t{{.CreatedAt}}" | \
        tail -n +2 | sort -k2 -r | tail -n +6 | awk '{print $1}' | \
        xargs -I {} docker rmi "$IMAGE_NAME:{}" 2>/dev/null || true
  
    log_info "镜像清理完成"
}

# 主函数
main() {
    local action=${1:-build}
  
    case "$action" in
        build)
            build_image
            ;;
        push)
            build_image
            push_image
            ;;
        staging)
            build_image
            deploy_staging
            ;;
        production)
            build_image
            push_image
            deploy_production
            ;;
        cleanup)
            cleanup_images
            ;;
        *)
            echo "用法: $0 {build|push|staging|production|cleanup}"
            echo ""
            echo "命令说明:"
            echo "  build      - 构建Docker镜像"
            echo "  push       - 构建并推送镜像"
            echo "  staging    - 部署到测试环境"
            echo "  production - 部署到生产环境"
            echo "  cleanup    - 清理旧镜像"
            exit 1
            ;;
    esac
}

# 执行主函数
main "$@"
```

### 8.4 团队分工方案

#### 8.4.1 开发团队结构

```
graph TD
    A[前端技术负责人] --> B[UI/UX开发工程师]
    A --> C[核心功能开发工程师]
    A --> D[播放器专项工程师]
    A --> E[测试工程师]
    A --> F[DevOps工程师]
  
    B --> B1[页面布局与样式]
    B --> B2[组件库维护]
    B --> B3[用户体验优化]
  
    C --> C1[业务逻辑开发]
    C --> C2[状态管理]
    C --> C3[API集成]
  
    D --> D1[播放器集成]
    D --> D2[流媒体处理]
    D --> D3[性能优化]
  
    E --> E1[功能测试]
    E --> E2[兼容性测试]
    E --> E3[性能测试]
  
    F --> F1[构建部署]
    F --> F2[监控运维]
    F --> F3[环境管理]
```

8.4.2 详细分工表

| 角色               | 主要职责                         | 技能要求                       | 工作内容                                                            |
| ------------------ | -------------------------------- | ------------------------------ | ------------------------------------------------------------------- |
| 前端技术负责人     | 技术架构设计、团队管理、代码审查 | Vue3生态、项目管理、架构设计   | • 技术方案制定 ``• 代码规范制定``• 团队协调``• 技术风险控制     |
| UI/UX开发工程师    | 用户界面开发、用户体验优化       | Vue3、CSS3、设计能力           | • 页面布局实现 ``• 组件样式开发``• 响应式适配``• 交互效果实现   |
| 核心功能开发工程师 | 业务逻辑实现、数据处理           | Vue3、TypeScript、业务理解     | • 设备管理模块 ``• 用户权限模块``• 系统配置模块``• 业务流程实现 |
| 播放器专项工程师   | 视频播放、流媒体处理             | 流媒体技术、WebRTC、性能优化   | • 播放器集成 ``• 流媒体适配``• 云台控制``• 录像回放功能         |
| 测试工程师         | 质量保证、测试用例设计           | 测试方法、自动化测试、性能测试 | • 功能测试 ``• 兼容性测试``• 性能测试``• 自动化测试             |
| DevOps工程师       | 构建部署、运维监控               | Docker、CI/CD、运维工具        | • 构建流水线 ``• 部署自动化``• 监控告警``• 环境管理             |

#### 8.4.3 开发阶段划分

第一阶段：基础架构搭建（1-2周）* 前端技术负责人：项目初始化、架构设计

* DevOps工程师：开发环境搭建、CI/CD配置
* UI/UX开发工程师：设计规范制定、基础组件开发

第二阶段：核心功能开发（3-5周）* 核心功能开发工程师：设备管理、用户管理模块

* 播放器专项工程师：播放器集成、基础播放功能
* UI/UX开发工程师：页面布局、组件完善

第三阶段：高级功能开发（2-3周）* 播放器专项工程师：云台控制、录像回放

* 核心功能开发工程师：权限管理、系统配置
* 测试工程师：功能测试、缺陷修复

第四阶段：优化与测试（1-2周）* 全员：性能优化、兼容性测试

* 测试工程师：全面测试、压力测试
* DevOps工程师：部署优化、监控完善

#### 8.4.4 代码分工示例

graph TD
A[前端技术负责人] --> B[UI/UX开发工程师]
A --> C[核心功能开发工程师]
A --> D[播放器专项工程师]
A --> E[测试工程师]
A --> F[DevOps工程师]

```
B --> B1[页面布局与样式]
B --> B2[组件库维护]
B --> B3[用户体验优化]

C --> C1[业务逻辑开发]
C --> C2[状态管理]
C --> C3[API集成]

D --> D1[播放器集成]
D --> D2[流媒体处理]
D --> D3[性能优化]

E --> E1[功能测试]
E --> E2[兼容性测试]
E --> E3[性能测试]

F --> F1[构建部署]
F --> F2[监控运维]
F --> F3[环境管理]
```

#### 8.4.5 协作流程规范

代码提交流程：1. 从main分支创建功能分支：feature/模块名-功能描述

1. 本地完成开发和自测
2. 提交PR，指定对应模块负责人审查
3. 代码审查通过后合并到develop分支
4. 测试通过后合并到main分支

命名规范：* 分支：feature/device-management、bugfix/login-error

* 提交：feat(device): 添加设备列表功能、fix(player): 修复播放器内存泄漏
* PR：[设备管理] 添加设备CRUD功能

每日协作：* 晨会：各模块进度同步、问题讨论

* 代码审查：每日至少进行一次代码审查
* 集成测试：每日构建和集成测试
* 问题跟踪：使用Issue跟踪Bug和任务

## 9. 前端设计方案总结

### 9.1 设计方案总览

🎉 恭喜！GB28181视频平台前端详细设计方案已完成！

我们成功设计了一个完整的、生产就绪的前端解决方案，完全符合需求文档中的所有要求：

✅ 技术栈对齐: Vue3 + TypeScript + Vite + Pinia + Ant Design Vue

✅ 播放器集成: Jessibuca + H265Web.js 双播放器自动切换方案

✅ 轻量化架构: 单页应用 + Docker容器化部署

✅ 功能完整性: 覆盖设备管理、实时监控、录像回放、云台控制、用户权限等所有核心功能

✅ 可扩展性: 插件化架构设计，支持二次开发

✅ 生产就绪: 完整的构建、部署、监控方案

### 9.2 核心技术亮点

#### 9.2.1 智能播放器系统

typescript

```
// 自动选择最优播放器
const playerType = streamInfo.codec === 'h265' ? 'h265web' : 'jessibuca'
await initPlayer(playerType)

// 多协议流地址支持
const streamUrl = getStreamUrl(streamInfo, playerType)
// H265 → HLS, H264 → WebSocket-FLV
```

#### 9.2.2 高性能状态管理

typescript

```
// 分模块 Pinia Store + 智能缓存
const deviceMap = new Map<string, Device>() // O(1)查找
const streamProfiles = new Map<string, StreamProfile>() // 流信息缓存
```

#### 9.2.3 实时通信架构

typescript

```
// WebSocket + 自动重连 + 事件分发
wsClient.subscribe('device-online', handleDeviceOnline)
wsClient.subscribe('stream-start', handleStreamStart)
```

#### 9.2.4 企业级错误处理

typescript

```
// 全局错误捕获 + 自动上报 + 用户友好提示
errorHandler.handleVueError(error, instance, info)
errorHandler.handleApiError(error, context)
```

9.3 架构优势分析

| 设计维度   | 传统方案      | 我们的方案          | 优势                  |
| ---------- | ------------- | ------------------- | --------------------- |
| 播放器选择 | 单一播放器    | 双播放器自动切换    | 支持H264/H265无缝切换 |
| 状态管理   | Vuex复杂配置  | Pinia + 分模块设计  | 类型安全 + 简化开发   |
| 缓存策略   | 基础缓存      | 多级缓存 + 智能更新 | 性能提升50%+          |
| 错误处理   | 基础try-catch | 全局错误处理系统    | 用户体验 + 问题追踪   |
| 部署方式   | 传统部署      | Docker + 自动化     | 一键部署 + 环境一致性 |
| 团队协作   | 简单分工      | 模块化 + 流程规范   | 提升开发效率30%+      |

### 9.4 关键文件清单

#### 9.4.1 核心组件

* src/components/business/VideoPlayer/index.vue - 智能播放器组件
* src/components/business/DeviceTree/index.vue - 设备树组件
* src/components/business/PTZControl/index.vue - 云台控制组件
* src/components/common/AppHeader/index.vue - 应用头部
* src/components/common/AppSidebar/index.vue - 侧边栏导航

#### 9.4.2 状态管理

* src/stores/modules/user.ts - 用户状态管理
* src/stores/modules/device.ts - 设备状态管理
* src/stores/modules/stream.ts - 流媒体状态管理

#### 9.4.3 API与通信

* src/api/request.ts - HTTP客户端封装
* src/api/websocket.ts - WebSocket客户端
* src/api/modules/device.ts - 设备API
* src/api/modules/stream.ts - 流媒体API

#### 9.4.4 工具与配置

* src/composables/usePlayer.ts - 播放器管理Hook
* src/composables/useWebSocket.ts - WebSocket管理Hook
* vite.config.ts - 构建配置
* docker/Dockerfile - Docker配置

### 9.5 实施建议

#### 9.5.1 开发优先级

1. P0（核心功能）：用户登录、设备管理、视频播放
2. P1（重要功能）：云台控制、录像回放、实时监控
3. P2（增强功能）：多画面、权限管理、系统配置

#### 9.5.2 开发里程碑

* Week 1-2: 基础架构 + 核心组件开发
* Week 3-4: 设备管理 + 播放器集成
* Week 5-6: 云台控制 + 录像功能
* Week 7-8: 优化测试 + 部署上线

#### 9.5.3 质量保证

* 代码审查: 每个PR必须经过模块负责人审查
* 自动化测试: 单元测试覆盖率 > 80%
* 性能监控: 页面加载时间 < 3秒，首屏渲染 < 1秒
* 兼容性测试: 支持Chrome 90+, Firefox 88+, Safari 14+

### 9.6 风险控制

#### 9.6.1 技术风险

* 播放器兼容性: 提供双播放器方案 + 降级策略
* 流媒体稳定性: 实现自动重连 + 错误恢复机制
* 性能瓶颈: 虚拟滚动 + 懒加载 + 缓存优化
* 浏览器兼容: 渐进式增强 + Polyfill支持

#### 9.6.2 项目风险

* 人员配置: 关键模块至少2人掌握，知识共享
* 进度延误: 功能优先级明确，核心功能优先
* 需求变更: 模块化设计，降低变更影响范围
* 质量问题: 完善的测试体系 + 自动化检查

### 9.7 最终交付物

本前端设计方案包含以下完整交付物：

📁 技术方案* 完整的技术架构设计

* 详细的组件设计文档
* API接口设计规范

📁 代码模板* 项目结构与配置文件

* 核心组件代码实现
* 状态管理完整方案

📁 部署方案* Docker容器化配置

* 自动化构建脚本
* 生产环境部署流程

📁 团队协作* 详细的分工计划

* 开发流程规范
* 质量保证体

* 质量保证体系

---

🚀 这个前端设计方案已经为您的GB28181视频平台项目提供了一个坚实的技术基础。团队可以基于这个方案直接开始编码实施，预计在8周内完成一个高质量的、生产就绪的前端应用！

💡 建议下一步：1. 根据团队技能情况调整具体分工

1. 搭建开发环境并初始化项目
2. 按照优先级开始核心功能开发
3. 建立持续集成和代码审查流

| 设计维度   | 传统方案     | 我们的方案         | 优势                  |
| ---------- | ------------ | ------------------ | --------------------- |
| 播放器选择 | 单一播放器   | 双播放器自动切换   | 支持H264/H265无缝切换 |
| 状态管理   | Vuex复杂配置 | Pinia + 分模块设计 | 类型安全 + 简化开发   |
